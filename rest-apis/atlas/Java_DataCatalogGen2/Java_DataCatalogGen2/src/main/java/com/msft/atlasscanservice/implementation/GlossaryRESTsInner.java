/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.msft.atlasscanservice.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.CloudException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import okhttp3.ResponseBody;
import retrofit2.Response;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.HTTP;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Path;
import retrofit2.http.Query;
import rx.Observable;
import rx.functions.Func1;

/**
 * An instance of this class provides access to all the operations defined
 * in GlossaryRESTs.
 */
public class GlossaryRESTsInner {
    /** The Retrofit service to perform REST calls. */
    private GlossaryRESTsService service;
    /** The service client containing this operation class. */
    private DataCatalogClientImpl client;

    /**
     * Initializes an instance of GlossaryRESTsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public GlossaryRESTsInner(Retrofit retrofit, DataCatalogClientImpl client) {
        this.service = retrofit.create(GlossaryRESTsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for GlossaryRESTs to be
     * used by Retrofit to perform actually REST calls.
     */
    interface GlossaryRESTsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs getGlossaries" })
        @GET("v2/glossary")
        Observable<Response<ResponseBody>> getGlossaries(@Query("limit") String limit, @Query("offset") String offset, @Query("sort") String sort, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs createGlossary" })
        @POST("v2/glossary")
        Observable<Response<ResponseBody>> createGlossary(@Body JsonAtlasGlossaryInner atlasGlossary, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs createGlossaryCategories" })
        @POST("v2/glossary/categories")
        Observable<Response<ResponseBody>> createGlossaryCategories(@Body List<JsonAtlasGlossaryCategoryInner> glossaryCategory, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs createGlossaryCategory" })
        @POST("v2/glossary/category")
        Observable<Response<ResponseBody>> createGlossaryCategory(@Body JsonAtlasGlossaryCategoryInner glossaryCategory, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs getGlossaryCategory" })
        @GET("v2/glossary/category/{categoryGuid}")
        Observable<Response<ResponseBody>> getGlossaryCategory(@Path("categoryGuid") String categoryGuid, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs updateGlossaryCategory" })
        @PUT("v2/glossary/category/{categoryGuid}")
        Observable<Response<ResponseBody>> updateGlossaryCategory(@Path("categoryGuid") String categoryGuid, @Body JsonAtlasGlossaryCategoryInner glossaryCategory, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs deleteGlossaryCategory" })
        @HTTP(path = "v2/glossary/category/{categoryGuid}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteGlossaryCategory(@Path("categoryGuid") String categoryGuid, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs partialUpdateGlossaryCategory" })
        @PUT("v2/glossary/category/{categoryGuid}/partial")
        Observable<Response<ResponseBody>> partialUpdateGlossaryCategory(@Path("categoryGuid") String categoryGuid, @Body Map<String, String> partialUpdates, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs getRelatedCategories" })
        @GET("v2/glossary/category/{categoryGuid}/related")
        Observable<Response<ResponseBody>> getRelatedCategories(@Path("categoryGuid") String categoryGuid, @Query("limit") String limit, @Query("offset") String offset, @Query("sort") String sort, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs getCategoryTerms" })
        @GET("v2/glossary/category/{categoryGuid}/terms")
        Observable<Response<ResponseBody>> getCategoryTerms(@Path("categoryGuid") String categoryGuid, @Query("limit") String limit, @Query("offset") String offset, @Query("sort") String sort, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs createGlossaryTerm" })
        @POST("v2/glossary/term")
        Observable<Response<ResponseBody>> createGlossaryTerm(@Body JsonAtlasGlossaryTermInner glossaryTerm, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs getGlossaryTerm" })
        @GET("v2/glossary/term/{termGuid}")
        Observable<Response<ResponseBody>> getGlossaryTerm(@Path("termGuid") String termGuid, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs updateGlossaryTerm" })
        @PUT("v2/glossary/term/{termGuid}")
        Observable<Response<ResponseBody>> updateGlossaryTerm(@Path("termGuid") String termGuid, @Body JsonAtlasGlossaryTermInner glossaryTerm, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs deleteGlossaryTerm" })
        @HTTP(path = "v2/glossary/term/{termGuid}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteGlossaryTerm(@Path("termGuid") String termGuid, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs partialUpdateGlossaryTerm" })
        @PUT("v2/glossary/term/{termGuid}/partial")
        Observable<Response<ResponseBody>> partialUpdateGlossaryTerm(@Path("termGuid") String termGuid, @Body Map<String, String> partialUpdates, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs createGlossaryTerms" })
        @POST("v2/glossary/terms")
        Observable<Response<ResponseBody>> createGlossaryTerms(@Body List<JsonAtlasGlossaryTermInner> glossaryTerm, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs getEntitiesAssignedWithTerm" })
        @GET("v2/glossary/terms/{termGuid}/assignedEntities")
        Observable<Response<ResponseBody>> getEntitiesAssignedWithTerm(@Path("termGuid") String termGuid, @Query("limit") String limit, @Query("offset") String offset, @Query("sort") String sort, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs assignTermToEntities" })
        @POST("v2/glossary/terms/{termGuid}/assignedEntities")
        Observable<Response<ResponseBody>> assignTermToEntities(@Path("termGuid") String termGuid, @Body List<JsonAtlasRelatedObjectIdInner> relatedObjectIds, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs removeTermAssignmentFromEntities" })
        @HTTP(path = "v2/glossary/terms/{termGuid}/assignedEntities", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> removeTermAssignmentFromEntities(@Path("termGuid") String termGuid, @Body List<JsonAtlasRelatedObjectIdInner> relatedObjectIds, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs getRelatedTerms" })
        @GET("v2/glossary/terms/{termGuid}/related")
        Observable<Response<ResponseBody>> getRelatedTerms(@Path("termGuid") String termGuid, @Query("limit") String limit, @Query("offset") String offset, @Query("sort") String sort, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs getGlossary" })
        @GET("v2/glossary/{glossaryGuid}")
        Observable<Response<ResponseBody>> getGlossary(@Path("glossaryGuid") String glossaryGuid, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs updateGlossary" })
        @PUT("v2/glossary/{glossaryGuid}")
        Observable<Response<ResponseBody>> updateGlossary(@Path("glossaryGuid") String glossaryGuid, @Body JsonAtlasGlossaryInner updatedGlossary, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs deleteGlossary" })
        @HTTP(path = "v2/glossary/{glossaryGuid}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteGlossary(@Path("glossaryGuid") String glossaryGuid, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs getGlossaryCategories" })
        @GET("v2/glossary/{glossaryGuid}/categories")
        Observable<Response<ResponseBody>> getGlossaryCategories(@Path("glossaryGuid") String glossaryGuid, @Query("limit") String limit, @Query("offset") String offset, @Query("sort") String sort, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs getGlossaryCategoriesHeaders" })
        @GET("v2/glossary/{glossaryGuid}/categories/headers")
        Observable<Response<ResponseBody>> getGlossaryCategoriesHeaders(@Path("glossaryGuid") String glossaryGuid, @Query("limit") String limit, @Query("offset") String offset, @Query("sort") String sort, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs getDetailedGlossary" })
        @GET("v2/glossary/{glossaryGuid}/detailed")
        Observable<Response<ResponseBody>> getDetailedGlossary(@Path("glossaryGuid") String glossaryGuid, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs partialUpdateGlossary" })
        @PUT("v2/glossary/{glossaryGuid}/partial")
        Observable<Response<ResponseBody>> partialUpdateGlossary(@Path("glossaryGuid") String glossaryGuid, @Body Map<String, String> partialUpdates, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs getGlossaryTerms" })
        @GET("v2/glossary/{glossaryGuid}/terms")
        Observable<Response<ResponseBody>> getGlossaryTerms(@Path("glossaryGuid") String glossaryGuid, @Query("limit") String limit, @Query("offset") String offset, @Query("sort") String sort, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs getGlossaryTermHeaders" })
        @GET("v2/glossary/{glossaryGuid}/terms/headers")
        Observable<Response<ResponseBody>> getGlossaryTermHeaders(@Path("glossaryGuid") String glossaryGuid, @Query("limit") String limit, @Query("offset") String offset, @Query("sort") String sort, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.GlossaryRESTs getTermsByGlossaryName" })
        @GET("v2/glossary/name/{glossaryName}/terms")
        Observable<Response<ResponseBody>> getTermsByGlossaryName(@Path("glossaryName") String glossaryName, @Query("limit") String limit, @Query("offset") String offset, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Gets all glossaries registered with Atlas.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;JsonAtlasGlossaryInner&gt; object if successful.
     */
    public List<JsonAtlasGlossaryInner> getGlossaries() {
        return getGlossariesWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets all glossaries registered with Atlas.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<JsonAtlasGlossaryInner>> getGlossariesAsync(final ServiceCallback<List<JsonAtlasGlossaryInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getGlossariesWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets all glossaries registered with Atlas.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;JsonAtlasGlossaryInner&gt; object
     */
    public Observable<List<JsonAtlasGlossaryInner>> getGlossariesAsync() {
        return getGlossariesWithServiceResponseAsync().map(new Func1<ServiceResponse<List<JsonAtlasGlossaryInner>>, List<JsonAtlasGlossaryInner>>() {
            @Override
            public List<JsonAtlasGlossaryInner> call(ServiceResponse<List<JsonAtlasGlossaryInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all glossaries registered with Atlas.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;JsonAtlasGlossaryInner&gt; object
     */
    public Observable<ServiceResponse<List<JsonAtlasGlossaryInner>>> getGlossariesWithServiceResponseAsync() {
        return service.getGlossaries(this.client.limit(), this.client.offset(), this.client.sort(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<JsonAtlasGlossaryInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<JsonAtlasGlossaryInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<JsonAtlasGlossaryInner>> clientResponse = getGlossariesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<JsonAtlasGlossaryInner>> getGlossariesDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<JsonAtlasGlossaryInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<JsonAtlasGlossaryInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a glossary.
     *
     * @param atlasGlossary Glossary definition, terms &amp; categories can be anchored to a glossary.
     Using the anchor attribute when creating the Term/Category.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasGlossaryInner object if successful.
     */
    public JsonAtlasGlossaryInner createGlossary(JsonAtlasGlossaryInner atlasGlossary) {
        return createGlossaryWithServiceResponseAsync(atlasGlossary).toBlocking().single().body();
    }

    /**
     * Creates a glossary.
     *
     * @param atlasGlossary Glossary definition, terms &amp; categories can be anchored to a glossary.
     Using the anchor attribute when creating the Term/Category.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasGlossaryInner> createGlossaryAsync(JsonAtlasGlossaryInner atlasGlossary, final ServiceCallback<JsonAtlasGlossaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(createGlossaryWithServiceResponseAsync(atlasGlossary), serviceCallback);
    }

    /**
     * Creates a glossary.
     *
     * @param atlasGlossary Glossary definition, terms &amp; categories can be anchored to a glossary.
     Using the anchor attribute when creating the Term/Category.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryInner object
     */
    public Observable<JsonAtlasGlossaryInner> createGlossaryAsync(JsonAtlasGlossaryInner atlasGlossary) {
        return createGlossaryWithServiceResponseAsync(atlasGlossary).map(new Func1<ServiceResponse<JsonAtlasGlossaryInner>, JsonAtlasGlossaryInner>() {
            @Override
            public JsonAtlasGlossaryInner call(ServiceResponse<JsonAtlasGlossaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a glossary.
     *
     * @param atlasGlossary Glossary definition, terms &amp; categories can be anchored to a glossary.
     Using the anchor attribute when creating the Term/Category.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryInner object
     */
    public Observable<ServiceResponse<JsonAtlasGlossaryInner>> createGlossaryWithServiceResponseAsync(JsonAtlasGlossaryInner atlasGlossary) {
        if (atlasGlossary == null) {
            throw new IllegalArgumentException("Parameter atlasGlossary is required and cannot be null.");
        }
        Validator.validate(atlasGlossary);
        return service.createGlossary(atlasGlossary, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasGlossaryInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasGlossaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasGlossaryInner> clientResponse = createGlossaryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasGlossaryInner> createGlossaryDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasGlossaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasGlossaryInner>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates glossary category in bulk.
     *
     * @param glossaryCategory An array of glossary category definitions to be created.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;JsonAtlasGlossaryCategoryInner&gt; object if successful.
     */
    public List<JsonAtlasGlossaryCategoryInner> createGlossaryCategories(List<JsonAtlasGlossaryCategoryInner> glossaryCategory) {
        return createGlossaryCategoriesWithServiceResponseAsync(glossaryCategory).toBlocking().single().body();
    }

    /**
     * Creates glossary category in bulk.
     *
     * @param glossaryCategory An array of glossary category definitions to be created.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<JsonAtlasGlossaryCategoryInner>> createGlossaryCategoriesAsync(List<JsonAtlasGlossaryCategoryInner> glossaryCategory, final ServiceCallback<List<JsonAtlasGlossaryCategoryInner>> serviceCallback) {
        return ServiceFuture.fromResponse(createGlossaryCategoriesWithServiceResponseAsync(glossaryCategory), serviceCallback);
    }

    /**
     * Creates glossary category in bulk.
     *
     * @param glossaryCategory An array of glossary category definitions to be created.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;JsonAtlasGlossaryCategoryInner&gt; object
     */
    public Observable<List<JsonAtlasGlossaryCategoryInner>> createGlossaryCategoriesAsync(List<JsonAtlasGlossaryCategoryInner> glossaryCategory) {
        return createGlossaryCategoriesWithServiceResponseAsync(glossaryCategory).map(new Func1<ServiceResponse<List<JsonAtlasGlossaryCategoryInner>>, List<JsonAtlasGlossaryCategoryInner>>() {
            @Override
            public List<JsonAtlasGlossaryCategoryInner> call(ServiceResponse<List<JsonAtlasGlossaryCategoryInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates glossary category in bulk.
     *
     * @param glossaryCategory An array of glossary category definitions to be created.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;JsonAtlasGlossaryCategoryInner&gt; object
     */
    public Observable<ServiceResponse<List<JsonAtlasGlossaryCategoryInner>>> createGlossaryCategoriesWithServiceResponseAsync(List<JsonAtlasGlossaryCategoryInner> glossaryCategory) {
        if (glossaryCategory == null) {
            throw new IllegalArgumentException("Parameter glossaryCategory is required and cannot be null.");
        }
        Validator.validate(glossaryCategory);
        return service.createGlossaryCategories(glossaryCategory, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<JsonAtlasGlossaryCategoryInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<JsonAtlasGlossaryCategoryInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<JsonAtlasGlossaryCategoryInner>> clientResponse = createGlossaryCategoriesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<JsonAtlasGlossaryCategoryInner>> createGlossaryCategoriesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<JsonAtlasGlossaryCategoryInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<JsonAtlasGlossaryCategoryInner>>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a glossary category.
     *
     * @param glossaryCategory The glossary category definition. A category must be anchored to a Glossary when creating.
     Optionally, terms belonging to the category and the hierarchy can also be defined during creation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasGlossaryCategoryInner object if successful.
     */
    public JsonAtlasGlossaryCategoryInner createGlossaryCategory(JsonAtlasGlossaryCategoryInner glossaryCategory) {
        return createGlossaryCategoryWithServiceResponseAsync(glossaryCategory).toBlocking().single().body();
    }

    /**
     * Creates a glossary category.
     *
     * @param glossaryCategory The glossary category definition. A category must be anchored to a Glossary when creating.
     Optionally, terms belonging to the category and the hierarchy can also be defined during creation.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasGlossaryCategoryInner> createGlossaryCategoryAsync(JsonAtlasGlossaryCategoryInner glossaryCategory, final ServiceCallback<JsonAtlasGlossaryCategoryInner> serviceCallback) {
        return ServiceFuture.fromResponse(createGlossaryCategoryWithServiceResponseAsync(glossaryCategory), serviceCallback);
    }

    /**
     * Creates a glossary category.
     *
     * @param glossaryCategory The glossary category definition. A category must be anchored to a Glossary when creating.
     Optionally, terms belonging to the category and the hierarchy can also be defined during creation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryCategoryInner object
     */
    public Observable<JsonAtlasGlossaryCategoryInner> createGlossaryCategoryAsync(JsonAtlasGlossaryCategoryInner glossaryCategory) {
        return createGlossaryCategoryWithServiceResponseAsync(glossaryCategory).map(new Func1<ServiceResponse<JsonAtlasGlossaryCategoryInner>, JsonAtlasGlossaryCategoryInner>() {
            @Override
            public JsonAtlasGlossaryCategoryInner call(ServiceResponse<JsonAtlasGlossaryCategoryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a glossary category.
     *
     * @param glossaryCategory The glossary category definition. A category must be anchored to a Glossary when creating.
     Optionally, terms belonging to the category and the hierarchy can also be defined during creation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryCategoryInner object
     */
    public Observable<ServiceResponse<JsonAtlasGlossaryCategoryInner>> createGlossaryCategoryWithServiceResponseAsync(JsonAtlasGlossaryCategoryInner glossaryCategory) {
        if (glossaryCategory == null) {
            throw new IllegalArgumentException("Parameter glossaryCategory is required and cannot be null.");
        }
        Validator.validate(glossaryCategory);
        return service.createGlossaryCategory(glossaryCategory, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasGlossaryCategoryInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasGlossaryCategoryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasGlossaryCategoryInner> clientResponse = createGlossaryCategoryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasGlossaryCategoryInner> createGlossaryCategoryDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasGlossaryCategoryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasGlossaryCategoryInner>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets specific glossary category by its GUID.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasGlossaryCategoryInner object if successful.
     */
    public JsonAtlasGlossaryCategoryInner getGlossaryCategory(String categoryGuid) {
        return getGlossaryCategoryWithServiceResponseAsync(categoryGuid).toBlocking().single().body();
    }

    /**
     * Gets specific glossary category by its GUID.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasGlossaryCategoryInner> getGlossaryCategoryAsync(String categoryGuid, final ServiceCallback<JsonAtlasGlossaryCategoryInner> serviceCallback) {
        return ServiceFuture.fromResponse(getGlossaryCategoryWithServiceResponseAsync(categoryGuid), serviceCallback);
    }

    /**
     * Gets specific glossary category by its GUID.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryCategoryInner object
     */
    public Observable<JsonAtlasGlossaryCategoryInner> getGlossaryCategoryAsync(String categoryGuid) {
        return getGlossaryCategoryWithServiceResponseAsync(categoryGuid).map(new Func1<ServiceResponse<JsonAtlasGlossaryCategoryInner>, JsonAtlasGlossaryCategoryInner>() {
            @Override
            public JsonAtlasGlossaryCategoryInner call(ServiceResponse<JsonAtlasGlossaryCategoryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets specific glossary category by its GUID.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryCategoryInner object
     */
    public Observable<ServiceResponse<JsonAtlasGlossaryCategoryInner>> getGlossaryCategoryWithServiceResponseAsync(String categoryGuid) {
        if (categoryGuid == null) {
            throw new IllegalArgumentException("Parameter categoryGuid is required and cannot be null.");
        }
        return service.getGlossaryCategory(categoryGuid, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasGlossaryCategoryInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasGlossaryCategoryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasGlossaryCategoryInner> clientResponse = getGlossaryCategoryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasGlossaryCategoryInner> getGlossaryCategoryDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasGlossaryCategoryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasGlossaryCategoryInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the given glossary category by its GUID.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @param glossaryCategory The glossary category to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasGlossaryCategoryInner object if successful.
     */
    public JsonAtlasGlossaryCategoryInner updateGlossaryCategory(String categoryGuid, JsonAtlasGlossaryCategoryInner glossaryCategory) {
        return updateGlossaryCategoryWithServiceResponseAsync(categoryGuid, glossaryCategory).toBlocking().single().body();
    }

    /**
     * Updates the given glossary category by its GUID.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @param glossaryCategory The glossary category to be updated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasGlossaryCategoryInner> updateGlossaryCategoryAsync(String categoryGuid, JsonAtlasGlossaryCategoryInner glossaryCategory, final ServiceCallback<JsonAtlasGlossaryCategoryInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateGlossaryCategoryWithServiceResponseAsync(categoryGuid, glossaryCategory), serviceCallback);
    }

    /**
     * Updates the given glossary category by its GUID.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @param glossaryCategory The glossary category to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryCategoryInner object
     */
    public Observable<JsonAtlasGlossaryCategoryInner> updateGlossaryCategoryAsync(String categoryGuid, JsonAtlasGlossaryCategoryInner glossaryCategory) {
        return updateGlossaryCategoryWithServiceResponseAsync(categoryGuid, glossaryCategory).map(new Func1<ServiceResponse<JsonAtlasGlossaryCategoryInner>, JsonAtlasGlossaryCategoryInner>() {
            @Override
            public JsonAtlasGlossaryCategoryInner call(ServiceResponse<JsonAtlasGlossaryCategoryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the given glossary category by its GUID.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @param glossaryCategory The glossary category to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryCategoryInner object
     */
    public Observable<ServiceResponse<JsonAtlasGlossaryCategoryInner>> updateGlossaryCategoryWithServiceResponseAsync(String categoryGuid, JsonAtlasGlossaryCategoryInner glossaryCategory) {
        if (categoryGuid == null) {
            throw new IllegalArgumentException("Parameter categoryGuid is required and cannot be null.");
        }
        if (glossaryCategory == null) {
            throw new IllegalArgumentException("Parameter glossaryCategory is required and cannot be null.");
        }
        Validator.validate(glossaryCategory);
        return service.updateGlossaryCategory(categoryGuid, glossaryCategory, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasGlossaryCategoryInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasGlossaryCategoryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasGlossaryCategoryInner> clientResponse = updateGlossaryCategoryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasGlossaryCategoryInner> updateGlossaryCategoryDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasGlossaryCategoryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasGlossaryCategoryInner>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a glossary category.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteGlossaryCategory(String categoryGuid) {
        deleteGlossaryCategoryWithServiceResponseAsync(categoryGuid).toBlocking().single().body();
    }

    /**
     * Deletes a glossary category.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteGlossaryCategoryAsync(String categoryGuid, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteGlossaryCategoryWithServiceResponseAsync(categoryGuid), serviceCallback);
    }

    /**
     * Deletes a glossary category.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteGlossaryCategoryAsync(String categoryGuid) {
        return deleteGlossaryCategoryWithServiceResponseAsync(categoryGuid).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a glossary category.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteGlossaryCategoryWithServiceResponseAsync(String categoryGuid) {
        if (categoryGuid == null) {
            throw new IllegalArgumentException("Parameter categoryGuid is required and cannot be null.");
        }
        return service.deleteGlossaryCategory(categoryGuid, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteGlossaryCategoryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteGlossaryCategoryDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the glossary category partially.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @param partialUpdates A map containing keys as attribute names and values as corresponding attribute values for partial update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasGlossaryCategoryInner object if successful.
     */
    public JsonAtlasGlossaryCategoryInner partialUpdateGlossaryCategory(String categoryGuid, Map<String, String> partialUpdates) {
        return partialUpdateGlossaryCategoryWithServiceResponseAsync(categoryGuid, partialUpdates).toBlocking().single().body();
    }

    /**
     * Updates the glossary category partially.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @param partialUpdates A map containing keys as attribute names and values as corresponding attribute values for partial update.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasGlossaryCategoryInner> partialUpdateGlossaryCategoryAsync(String categoryGuid, Map<String, String> partialUpdates, final ServiceCallback<JsonAtlasGlossaryCategoryInner> serviceCallback) {
        return ServiceFuture.fromResponse(partialUpdateGlossaryCategoryWithServiceResponseAsync(categoryGuid, partialUpdates), serviceCallback);
    }

    /**
     * Updates the glossary category partially.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @param partialUpdates A map containing keys as attribute names and values as corresponding attribute values for partial update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryCategoryInner object
     */
    public Observable<JsonAtlasGlossaryCategoryInner> partialUpdateGlossaryCategoryAsync(String categoryGuid, Map<String, String> partialUpdates) {
        return partialUpdateGlossaryCategoryWithServiceResponseAsync(categoryGuid, partialUpdates).map(new Func1<ServiceResponse<JsonAtlasGlossaryCategoryInner>, JsonAtlasGlossaryCategoryInner>() {
            @Override
            public JsonAtlasGlossaryCategoryInner call(ServiceResponse<JsonAtlasGlossaryCategoryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the glossary category partially.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @param partialUpdates A map containing keys as attribute names and values as corresponding attribute values for partial update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryCategoryInner object
     */
    public Observable<ServiceResponse<JsonAtlasGlossaryCategoryInner>> partialUpdateGlossaryCategoryWithServiceResponseAsync(String categoryGuid, Map<String, String> partialUpdates) {
        if (categoryGuid == null) {
            throw new IllegalArgumentException("Parameter categoryGuid is required and cannot be null.");
        }
        if (partialUpdates == null) {
            throw new IllegalArgumentException("Parameter partialUpdates is required and cannot be null.");
        }
        Validator.validate(partialUpdates);
        return service.partialUpdateGlossaryCategory(categoryGuid, partialUpdates, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasGlossaryCategoryInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasGlossaryCategoryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasGlossaryCategoryInner> clientResponse = partialUpdateGlossaryCategoryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasGlossaryCategoryInner> partialUpdateGlossaryCategoryDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasGlossaryCategoryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasGlossaryCategoryInner>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all related categories (parent and children). Limit, offset, and sort parameters are currently not being enabled and won't work even they are passed.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, List&lt;JsonAtlasRelatedCategoryHeaderInner&gt;&gt; object if successful.
     */
    public Map<String, List<JsonAtlasRelatedCategoryHeaderInner>> getRelatedCategories(String categoryGuid) {
        return getRelatedCategoriesWithServiceResponseAsync(categoryGuid).toBlocking().single().body();
    }

    /**
     * Gets all related categories (parent and children). Limit, offset, and sort parameters are currently not being enabled and won't work even they are passed.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, List<JsonAtlasRelatedCategoryHeaderInner>>> getRelatedCategoriesAsync(String categoryGuid, final ServiceCallback<Map<String, List<JsonAtlasRelatedCategoryHeaderInner>>> serviceCallback) {
        return ServiceFuture.fromResponse(getRelatedCategoriesWithServiceResponseAsync(categoryGuid), serviceCallback);
    }

    /**
     * Gets all related categories (parent and children). Limit, offset, and sort parameters are currently not being enabled and won't work even they are passed.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Map&lt;String, List&lt;JsonAtlasRelatedCategoryHeaderInner&gt;&gt; object
     */
    public Observable<Map<String, List<JsonAtlasRelatedCategoryHeaderInner>>> getRelatedCategoriesAsync(String categoryGuid) {
        return getRelatedCategoriesWithServiceResponseAsync(categoryGuid).map(new Func1<ServiceResponse<Map<String, List<JsonAtlasRelatedCategoryHeaderInner>>>, Map<String, List<JsonAtlasRelatedCategoryHeaderInner>>>() {
            @Override
            public Map<String, List<JsonAtlasRelatedCategoryHeaderInner>> call(ServiceResponse<Map<String, List<JsonAtlasRelatedCategoryHeaderInner>>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all related categories (parent and children). Limit, offset, and sort parameters are currently not being enabled and won't work even they are passed.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Map&lt;String, List&lt;JsonAtlasRelatedCategoryHeaderInner&gt;&gt; object
     */
    public Observable<ServiceResponse<Map<String, List<JsonAtlasRelatedCategoryHeaderInner>>>> getRelatedCategoriesWithServiceResponseAsync(String categoryGuid) {
        if (categoryGuid == null) {
            throw new IllegalArgumentException("Parameter categoryGuid is required and cannot be null.");
        }
        return service.getRelatedCategories(categoryGuid, this.client.limit(), this.client.offset(), this.client.sort(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, List<JsonAtlasRelatedCategoryHeaderInner>>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, List<JsonAtlasRelatedCategoryHeaderInner>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, List<JsonAtlasRelatedCategoryHeaderInner>>> clientResponse = getRelatedCategoriesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, List<JsonAtlasRelatedCategoryHeaderInner>>> getRelatedCategoriesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Map<String, List<JsonAtlasRelatedCategoryHeaderInner>>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Map<String, List<JsonAtlasRelatedCategoryHeaderInner>>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all terms associated with the specific category.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;JsonAtlasRelatedTermHeaderInner&gt; object if successful.
     */
    public List<JsonAtlasRelatedTermHeaderInner> getCategoryTerms(String categoryGuid) {
        return getCategoryTermsWithServiceResponseAsync(categoryGuid).toBlocking().single().body();
    }

    /**
     * Gets all terms associated with the specific category.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<JsonAtlasRelatedTermHeaderInner>> getCategoryTermsAsync(String categoryGuid, final ServiceCallback<List<JsonAtlasRelatedTermHeaderInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getCategoryTermsWithServiceResponseAsync(categoryGuid), serviceCallback);
    }

    /**
     * Gets all terms associated with the specific category.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;JsonAtlasRelatedTermHeaderInner&gt; object
     */
    public Observable<List<JsonAtlasRelatedTermHeaderInner>> getCategoryTermsAsync(String categoryGuid) {
        return getCategoryTermsWithServiceResponseAsync(categoryGuid).map(new Func1<ServiceResponse<List<JsonAtlasRelatedTermHeaderInner>>, List<JsonAtlasRelatedTermHeaderInner>>() {
            @Override
            public List<JsonAtlasRelatedTermHeaderInner> call(ServiceResponse<List<JsonAtlasRelatedTermHeaderInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all terms associated with the specific category.
     *
     * @param categoryGuid The globally unique identifier of the category.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;JsonAtlasRelatedTermHeaderInner&gt; object
     */
    public Observable<ServiceResponse<List<JsonAtlasRelatedTermHeaderInner>>> getCategoryTermsWithServiceResponseAsync(String categoryGuid) {
        if (categoryGuid == null) {
            throw new IllegalArgumentException("Parameter categoryGuid is required and cannot be null.");
        }
        return service.getCategoryTerms(categoryGuid, this.client.limit(), this.client.offset(), this.client.sort(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<JsonAtlasRelatedTermHeaderInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<JsonAtlasRelatedTermHeaderInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<JsonAtlasRelatedTermHeaderInner>> clientResponse = getCategoryTermsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<JsonAtlasRelatedTermHeaderInner>> getCategoryTermsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<JsonAtlasRelatedTermHeaderInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<JsonAtlasRelatedTermHeaderInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a glossary term.
     *
     * @param glossaryTerm The glossary term definition. A term must be anchored to a Glossary at the time of creation.
     Optionally it can be categorized as well.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasGlossaryTermInner object if successful.
     */
    public JsonAtlasGlossaryTermInner createGlossaryTerm(JsonAtlasGlossaryTermInner glossaryTerm) {
        return createGlossaryTermWithServiceResponseAsync(glossaryTerm).toBlocking().single().body();
    }

    /**
     * Creates a glossary term.
     *
     * @param glossaryTerm The glossary term definition. A term must be anchored to a Glossary at the time of creation.
     Optionally it can be categorized as well.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasGlossaryTermInner> createGlossaryTermAsync(JsonAtlasGlossaryTermInner glossaryTerm, final ServiceCallback<JsonAtlasGlossaryTermInner> serviceCallback) {
        return ServiceFuture.fromResponse(createGlossaryTermWithServiceResponseAsync(glossaryTerm), serviceCallback);
    }

    /**
     * Creates a glossary term.
     *
     * @param glossaryTerm The glossary term definition. A term must be anchored to a Glossary at the time of creation.
     Optionally it can be categorized as well.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryTermInner object
     */
    public Observable<JsonAtlasGlossaryTermInner> createGlossaryTermAsync(JsonAtlasGlossaryTermInner glossaryTerm) {
        return createGlossaryTermWithServiceResponseAsync(glossaryTerm).map(new Func1<ServiceResponse<JsonAtlasGlossaryTermInner>, JsonAtlasGlossaryTermInner>() {
            @Override
            public JsonAtlasGlossaryTermInner call(ServiceResponse<JsonAtlasGlossaryTermInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a glossary term.
     *
     * @param glossaryTerm The glossary term definition. A term must be anchored to a Glossary at the time of creation.
     Optionally it can be categorized as well.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryTermInner object
     */
    public Observable<ServiceResponse<JsonAtlasGlossaryTermInner>> createGlossaryTermWithServiceResponseAsync(JsonAtlasGlossaryTermInner glossaryTerm) {
        if (glossaryTerm == null) {
            throw new IllegalArgumentException("Parameter glossaryTerm is required and cannot be null.");
        }
        Validator.validate(glossaryTerm);
        return service.createGlossaryTerm(glossaryTerm, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasGlossaryTermInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasGlossaryTermInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasGlossaryTermInner> clientResponse = createGlossaryTermDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasGlossaryTermInner> createGlossaryTermDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasGlossaryTermInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasGlossaryTermInner>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a specific glossary term by its GUID.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasGlossaryTermInner object if successful.
     */
    public JsonAtlasGlossaryTermInner getGlossaryTerm(String termGuid) {
        return getGlossaryTermWithServiceResponseAsync(termGuid).toBlocking().single().body();
    }

    /**
     * Gets a specific glossary term by its GUID.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasGlossaryTermInner> getGlossaryTermAsync(String termGuid, final ServiceCallback<JsonAtlasGlossaryTermInner> serviceCallback) {
        return ServiceFuture.fromResponse(getGlossaryTermWithServiceResponseAsync(termGuid), serviceCallback);
    }

    /**
     * Gets a specific glossary term by its GUID.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryTermInner object
     */
    public Observable<JsonAtlasGlossaryTermInner> getGlossaryTermAsync(String termGuid) {
        return getGlossaryTermWithServiceResponseAsync(termGuid).map(new Func1<ServiceResponse<JsonAtlasGlossaryTermInner>, JsonAtlasGlossaryTermInner>() {
            @Override
            public JsonAtlasGlossaryTermInner call(ServiceResponse<JsonAtlasGlossaryTermInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a specific glossary term by its GUID.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryTermInner object
     */
    public Observable<ServiceResponse<JsonAtlasGlossaryTermInner>> getGlossaryTermWithServiceResponseAsync(String termGuid) {
        if (termGuid == null) {
            throw new IllegalArgumentException("Parameter termGuid is required and cannot be null.");
        }
        return service.getGlossaryTerm(termGuid, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasGlossaryTermInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasGlossaryTermInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasGlossaryTermInner> clientResponse = getGlossaryTermDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasGlossaryTermInner> getGlossaryTermDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasGlossaryTermInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasGlossaryTermInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the given glossary term by its GUID.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @param glossaryTerm The glossary term to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasGlossaryTermInner object if successful.
     */
    public JsonAtlasGlossaryTermInner updateGlossaryTerm(String termGuid, JsonAtlasGlossaryTermInner glossaryTerm) {
        return updateGlossaryTermWithServiceResponseAsync(termGuid, glossaryTerm).toBlocking().single().body();
    }

    /**
     * Updates the given glossary term by its GUID.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @param glossaryTerm The glossary term to be updated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasGlossaryTermInner> updateGlossaryTermAsync(String termGuid, JsonAtlasGlossaryTermInner glossaryTerm, final ServiceCallback<JsonAtlasGlossaryTermInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateGlossaryTermWithServiceResponseAsync(termGuid, glossaryTerm), serviceCallback);
    }

    /**
     * Updates the given glossary term by its GUID.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @param glossaryTerm The glossary term to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryTermInner object
     */
    public Observable<JsonAtlasGlossaryTermInner> updateGlossaryTermAsync(String termGuid, JsonAtlasGlossaryTermInner glossaryTerm) {
        return updateGlossaryTermWithServiceResponseAsync(termGuid, glossaryTerm).map(new Func1<ServiceResponse<JsonAtlasGlossaryTermInner>, JsonAtlasGlossaryTermInner>() {
            @Override
            public JsonAtlasGlossaryTermInner call(ServiceResponse<JsonAtlasGlossaryTermInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the given glossary term by its GUID.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @param glossaryTerm The glossary term to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryTermInner object
     */
    public Observable<ServiceResponse<JsonAtlasGlossaryTermInner>> updateGlossaryTermWithServiceResponseAsync(String termGuid, JsonAtlasGlossaryTermInner glossaryTerm) {
        if (termGuid == null) {
            throw new IllegalArgumentException("Parameter termGuid is required and cannot be null.");
        }
        if (glossaryTerm == null) {
            throw new IllegalArgumentException("Parameter glossaryTerm is required and cannot be null.");
        }
        Validator.validate(glossaryTerm);
        return service.updateGlossaryTerm(termGuid, glossaryTerm, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasGlossaryTermInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasGlossaryTermInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasGlossaryTermInner> clientResponse = updateGlossaryTermDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasGlossaryTermInner> updateGlossaryTermDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasGlossaryTermInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasGlossaryTermInner>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a glossary term.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteGlossaryTerm(String termGuid) {
        deleteGlossaryTermWithServiceResponseAsync(termGuid).toBlocking().single().body();
    }

    /**
     * Deletes a glossary term.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteGlossaryTermAsync(String termGuid, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteGlossaryTermWithServiceResponseAsync(termGuid), serviceCallback);
    }

    /**
     * Deletes a glossary term.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteGlossaryTermAsync(String termGuid) {
        return deleteGlossaryTermWithServiceResponseAsync(termGuid).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a glossary term.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteGlossaryTermWithServiceResponseAsync(String termGuid) {
        if (termGuid == null) {
            throw new IllegalArgumentException("Parameter termGuid is required and cannot be null.");
        }
        return service.deleteGlossaryTerm(termGuid, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteGlossaryTermDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteGlossaryTermDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the glossary term partially.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @param partialUpdates A map containing keys as attribute names and values as corresponding attribute values to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasGlossaryTermInner object if successful.
     */
    public JsonAtlasGlossaryTermInner partialUpdateGlossaryTerm(String termGuid, Map<String, String> partialUpdates) {
        return partialUpdateGlossaryTermWithServiceResponseAsync(termGuid, partialUpdates).toBlocking().single().body();
    }

    /**
     * Updates the glossary term partially.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @param partialUpdates A map containing keys as attribute names and values as corresponding attribute values to be updated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasGlossaryTermInner> partialUpdateGlossaryTermAsync(String termGuid, Map<String, String> partialUpdates, final ServiceCallback<JsonAtlasGlossaryTermInner> serviceCallback) {
        return ServiceFuture.fromResponse(partialUpdateGlossaryTermWithServiceResponseAsync(termGuid, partialUpdates), serviceCallback);
    }

    /**
     * Updates the glossary term partially.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @param partialUpdates A map containing keys as attribute names and values as corresponding attribute values to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryTermInner object
     */
    public Observable<JsonAtlasGlossaryTermInner> partialUpdateGlossaryTermAsync(String termGuid, Map<String, String> partialUpdates) {
        return partialUpdateGlossaryTermWithServiceResponseAsync(termGuid, partialUpdates).map(new Func1<ServiceResponse<JsonAtlasGlossaryTermInner>, JsonAtlasGlossaryTermInner>() {
            @Override
            public JsonAtlasGlossaryTermInner call(ServiceResponse<JsonAtlasGlossaryTermInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the glossary term partially.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @param partialUpdates A map containing keys as attribute names and values as corresponding attribute values to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryTermInner object
     */
    public Observable<ServiceResponse<JsonAtlasGlossaryTermInner>> partialUpdateGlossaryTermWithServiceResponseAsync(String termGuid, Map<String, String> partialUpdates) {
        if (termGuid == null) {
            throw new IllegalArgumentException("Parameter termGuid is required and cannot be null.");
        }
        if (partialUpdates == null) {
            throw new IllegalArgumentException("Parameter partialUpdates is required and cannot be null.");
        }
        Validator.validate(partialUpdates);
        return service.partialUpdateGlossaryTerm(termGuid, partialUpdates, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasGlossaryTermInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasGlossaryTermInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasGlossaryTermInner> clientResponse = partialUpdateGlossaryTermDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasGlossaryTermInner> partialUpdateGlossaryTermDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasGlossaryTermInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasGlossaryTermInner>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates glossary terms in bulk.
     *
     * @param glossaryTerm An array of glossary term definitions to be created in bulk.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;JsonAtlasGlossaryTermInner&gt; object if successful.
     */
    public List<JsonAtlasGlossaryTermInner> createGlossaryTerms(List<JsonAtlasGlossaryTermInner> glossaryTerm) {
        return createGlossaryTermsWithServiceResponseAsync(glossaryTerm).toBlocking().single().body();
    }

    /**
     * Creates glossary terms in bulk.
     *
     * @param glossaryTerm An array of glossary term definitions to be created in bulk.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<JsonAtlasGlossaryTermInner>> createGlossaryTermsAsync(List<JsonAtlasGlossaryTermInner> glossaryTerm, final ServiceCallback<List<JsonAtlasGlossaryTermInner>> serviceCallback) {
        return ServiceFuture.fromResponse(createGlossaryTermsWithServiceResponseAsync(glossaryTerm), serviceCallback);
    }

    /**
     * Creates glossary terms in bulk.
     *
     * @param glossaryTerm An array of glossary term definitions to be created in bulk.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;JsonAtlasGlossaryTermInner&gt; object
     */
    public Observable<List<JsonAtlasGlossaryTermInner>> createGlossaryTermsAsync(List<JsonAtlasGlossaryTermInner> glossaryTerm) {
        return createGlossaryTermsWithServiceResponseAsync(glossaryTerm).map(new Func1<ServiceResponse<List<JsonAtlasGlossaryTermInner>>, List<JsonAtlasGlossaryTermInner>>() {
            @Override
            public List<JsonAtlasGlossaryTermInner> call(ServiceResponse<List<JsonAtlasGlossaryTermInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates glossary terms in bulk.
     *
     * @param glossaryTerm An array of glossary term definitions to be created in bulk.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;JsonAtlasGlossaryTermInner&gt; object
     */
    public Observable<ServiceResponse<List<JsonAtlasGlossaryTermInner>>> createGlossaryTermsWithServiceResponseAsync(List<JsonAtlasGlossaryTermInner> glossaryTerm) {
        if (glossaryTerm == null) {
            throw new IllegalArgumentException("Parameter glossaryTerm is required and cannot be null.");
        }
        Validator.validate(glossaryTerm);
        return service.createGlossaryTerms(glossaryTerm, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<JsonAtlasGlossaryTermInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<JsonAtlasGlossaryTermInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<JsonAtlasGlossaryTermInner>> clientResponse = createGlossaryTermsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<JsonAtlasGlossaryTermInner>> createGlossaryTermsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<JsonAtlasGlossaryTermInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<JsonAtlasGlossaryTermInner>>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all related objects assigned with the specified term.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;JsonAtlasRelatedObjectIdInner&gt; object if successful.
     */
    public List<JsonAtlasRelatedObjectIdInner> getEntitiesAssignedWithTerm(String termGuid) {
        return getEntitiesAssignedWithTermWithServiceResponseAsync(termGuid).toBlocking().single().body();
    }

    /**
     * Gets all related objects assigned with the specified term.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<JsonAtlasRelatedObjectIdInner>> getEntitiesAssignedWithTermAsync(String termGuid, final ServiceCallback<List<JsonAtlasRelatedObjectIdInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getEntitiesAssignedWithTermWithServiceResponseAsync(termGuid), serviceCallback);
    }

    /**
     * Gets all related objects assigned with the specified term.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;JsonAtlasRelatedObjectIdInner&gt; object
     */
    public Observable<List<JsonAtlasRelatedObjectIdInner>> getEntitiesAssignedWithTermAsync(String termGuid) {
        return getEntitiesAssignedWithTermWithServiceResponseAsync(termGuid).map(new Func1<ServiceResponse<List<JsonAtlasRelatedObjectIdInner>>, List<JsonAtlasRelatedObjectIdInner>>() {
            @Override
            public List<JsonAtlasRelatedObjectIdInner> call(ServiceResponse<List<JsonAtlasRelatedObjectIdInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all related objects assigned with the specified term.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;JsonAtlasRelatedObjectIdInner&gt; object
     */
    public Observable<ServiceResponse<List<JsonAtlasRelatedObjectIdInner>>> getEntitiesAssignedWithTermWithServiceResponseAsync(String termGuid) {
        if (termGuid == null) {
            throw new IllegalArgumentException("Parameter termGuid is required and cannot be null.");
        }
        return service.getEntitiesAssignedWithTerm(termGuid, this.client.limit(), this.client.offset(), this.client.sort(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<JsonAtlasRelatedObjectIdInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<JsonAtlasRelatedObjectIdInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<JsonAtlasRelatedObjectIdInner>> clientResponse = getEntitiesAssignedWithTermDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<JsonAtlasRelatedObjectIdInner>> getEntitiesAssignedWithTermDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<JsonAtlasRelatedObjectIdInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<JsonAtlasRelatedObjectIdInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Assigns the given term to the provided list of related objects.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @param relatedObjectIds An array of related object IDs to which the term has to be associated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void assignTermToEntities(String termGuid, List<JsonAtlasRelatedObjectIdInner> relatedObjectIds) {
        assignTermToEntitiesWithServiceResponseAsync(termGuid, relatedObjectIds).toBlocking().single().body();
    }

    /**
     * Assigns the given term to the provided list of related objects.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @param relatedObjectIds An array of related object IDs to which the term has to be associated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> assignTermToEntitiesAsync(String termGuid, List<JsonAtlasRelatedObjectIdInner> relatedObjectIds, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(assignTermToEntitiesWithServiceResponseAsync(termGuid, relatedObjectIds), serviceCallback);
    }

    /**
     * Assigns the given term to the provided list of related objects.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @param relatedObjectIds An array of related object IDs to which the term has to be associated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> assignTermToEntitiesAsync(String termGuid, List<JsonAtlasRelatedObjectIdInner> relatedObjectIds) {
        return assignTermToEntitiesWithServiceResponseAsync(termGuid, relatedObjectIds).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Assigns the given term to the provided list of related objects.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @param relatedObjectIds An array of related object IDs to which the term has to be associated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> assignTermToEntitiesWithServiceResponseAsync(String termGuid, List<JsonAtlasRelatedObjectIdInner> relatedObjectIds) {
        if (termGuid == null) {
            throw new IllegalArgumentException("Parameter termGuid is required and cannot be null.");
        }
        if (relatedObjectIds == null) {
            throw new IllegalArgumentException("Parameter relatedObjectIds is required and cannot be null.");
        }
        Validator.validate(relatedObjectIds);
        return service.assignTermToEntities(termGuid, relatedObjectIds, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = assignTermToEntitiesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> assignTermToEntitiesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes the term assignment for the given list of related objects.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @param relatedObjectIds An array of related object IDs from which the term has to be dissociated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void removeTermAssignmentFromEntities(String termGuid, List<JsonAtlasRelatedObjectIdInner> relatedObjectIds) {
        removeTermAssignmentFromEntitiesWithServiceResponseAsync(termGuid, relatedObjectIds).toBlocking().single().body();
    }

    /**
     * Deletes the term assignment for the given list of related objects.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @param relatedObjectIds An array of related object IDs from which the term has to be dissociated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> removeTermAssignmentFromEntitiesAsync(String termGuid, List<JsonAtlasRelatedObjectIdInner> relatedObjectIds, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(removeTermAssignmentFromEntitiesWithServiceResponseAsync(termGuid, relatedObjectIds), serviceCallback);
    }

    /**
     * Deletes the term assignment for the given list of related objects.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @param relatedObjectIds An array of related object IDs from which the term has to be dissociated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> removeTermAssignmentFromEntitiesAsync(String termGuid, List<JsonAtlasRelatedObjectIdInner> relatedObjectIds) {
        return removeTermAssignmentFromEntitiesWithServiceResponseAsync(termGuid, relatedObjectIds).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the term assignment for the given list of related objects.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @param relatedObjectIds An array of related object IDs from which the term has to be dissociated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> removeTermAssignmentFromEntitiesWithServiceResponseAsync(String termGuid, List<JsonAtlasRelatedObjectIdInner> relatedObjectIds) {
        if (termGuid == null) {
            throw new IllegalArgumentException("Parameter termGuid is required and cannot be null.");
        }
        if (relatedObjectIds == null) {
            throw new IllegalArgumentException("Parameter relatedObjectIds is required and cannot be null.");
        }
        Validator.validate(relatedObjectIds);
        return service.removeTermAssignmentFromEntities(termGuid, relatedObjectIds, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = removeTermAssignmentFromEntitiesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> removeTermAssignmentFromEntitiesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all related terms for a specific term by its GUID. Limit, offset, and sort parameters are currently not being enabled and won't work even they are passed.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, List&lt;JsonAtlasRelatedTermHeaderInner&gt;&gt; object if successful.
     */
    public Map<String, List<JsonAtlasRelatedTermHeaderInner>> getRelatedTerms(String termGuid) {
        return getRelatedTermsWithServiceResponseAsync(termGuid).toBlocking().single().body();
    }

    /**
     * Gets all related terms for a specific term by its GUID. Limit, offset, and sort parameters are currently not being enabled and won't work even they are passed.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, List<JsonAtlasRelatedTermHeaderInner>>> getRelatedTermsAsync(String termGuid, final ServiceCallback<Map<String, List<JsonAtlasRelatedTermHeaderInner>>> serviceCallback) {
        return ServiceFuture.fromResponse(getRelatedTermsWithServiceResponseAsync(termGuid), serviceCallback);
    }

    /**
     * Gets all related terms for a specific term by its GUID. Limit, offset, and sort parameters are currently not being enabled and won't work even they are passed.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Map&lt;String, List&lt;JsonAtlasRelatedTermHeaderInner&gt;&gt; object
     */
    public Observable<Map<String, List<JsonAtlasRelatedTermHeaderInner>>> getRelatedTermsAsync(String termGuid) {
        return getRelatedTermsWithServiceResponseAsync(termGuid).map(new Func1<ServiceResponse<Map<String, List<JsonAtlasRelatedTermHeaderInner>>>, Map<String, List<JsonAtlasRelatedTermHeaderInner>>>() {
            @Override
            public Map<String, List<JsonAtlasRelatedTermHeaderInner>> call(ServiceResponse<Map<String, List<JsonAtlasRelatedTermHeaderInner>>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all related terms for a specific term by its GUID. Limit, offset, and sort parameters are currently not being enabled and won't work even they are passed.
     *
     * @param termGuid The globally unique identifier for glossary term.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Map&lt;String, List&lt;JsonAtlasRelatedTermHeaderInner&gt;&gt; object
     */
    public Observable<ServiceResponse<Map<String, List<JsonAtlasRelatedTermHeaderInner>>>> getRelatedTermsWithServiceResponseAsync(String termGuid) {
        if (termGuid == null) {
            throw new IllegalArgumentException("Parameter termGuid is required and cannot be null.");
        }
        return service.getRelatedTerms(termGuid, this.client.limit(), this.client.offset(), this.client.sort(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, List<JsonAtlasRelatedTermHeaderInner>>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, List<JsonAtlasRelatedTermHeaderInner>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, List<JsonAtlasRelatedTermHeaderInner>>> clientResponse = getRelatedTermsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, List<JsonAtlasRelatedTermHeaderInner>>> getRelatedTermsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Map<String, List<JsonAtlasRelatedTermHeaderInner>>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Map<String, List<JsonAtlasRelatedTermHeaderInner>>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a specific Glossary by its GUID.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasGlossaryInner object if successful.
     */
    public JsonAtlasGlossaryInner getGlossary(String glossaryGuid) {
        return getGlossaryWithServiceResponseAsync(glossaryGuid).toBlocking().single().body();
    }

    /**
     * Gets a specific Glossary by its GUID.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasGlossaryInner> getGlossaryAsync(String glossaryGuid, final ServiceCallback<JsonAtlasGlossaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(getGlossaryWithServiceResponseAsync(glossaryGuid), serviceCallback);
    }

    /**
     * Gets a specific Glossary by its GUID.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryInner object
     */
    public Observable<JsonAtlasGlossaryInner> getGlossaryAsync(String glossaryGuid) {
        return getGlossaryWithServiceResponseAsync(glossaryGuid).map(new Func1<ServiceResponse<JsonAtlasGlossaryInner>, JsonAtlasGlossaryInner>() {
            @Override
            public JsonAtlasGlossaryInner call(ServiceResponse<JsonAtlasGlossaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a specific Glossary by its GUID.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryInner object
     */
    public Observable<ServiceResponse<JsonAtlasGlossaryInner>> getGlossaryWithServiceResponseAsync(String glossaryGuid) {
        if (glossaryGuid == null) {
            throw new IllegalArgumentException("Parameter glossaryGuid is required and cannot be null.");
        }
        return service.getGlossary(glossaryGuid, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasGlossaryInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasGlossaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasGlossaryInner> clientResponse = getGlossaryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasGlossaryInner> getGlossaryDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasGlossaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasGlossaryInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the given glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @param updatedGlossary The glossary definition to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasGlossaryInner object if successful.
     */
    public JsonAtlasGlossaryInner updateGlossary(String glossaryGuid, JsonAtlasGlossaryInner updatedGlossary) {
        return updateGlossaryWithServiceResponseAsync(glossaryGuid, updatedGlossary).toBlocking().single().body();
    }

    /**
     * Updates the given glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @param updatedGlossary The glossary definition to be updated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasGlossaryInner> updateGlossaryAsync(String glossaryGuid, JsonAtlasGlossaryInner updatedGlossary, final ServiceCallback<JsonAtlasGlossaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateGlossaryWithServiceResponseAsync(glossaryGuid, updatedGlossary), serviceCallback);
    }

    /**
     * Updates the given glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @param updatedGlossary The glossary definition to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryInner object
     */
    public Observable<JsonAtlasGlossaryInner> updateGlossaryAsync(String glossaryGuid, JsonAtlasGlossaryInner updatedGlossary) {
        return updateGlossaryWithServiceResponseAsync(glossaryGuid, updatedGlossary).map(new Func1<ServiceResponse<JsonAtlasGlossaryInner>, JsonAtlasGlossaryInner>() {
            @Override
            public JsonAtlasGlossaryInner call(ServiceResponse<JsonAtlasGlossaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the given glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @param updatedGlossary The glossary definition to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryInner object
     */
    public Observable<ServiceResponse<JsonAtlasGlossaryInner>> updateGlossaryWithServiceResponseAsync(String glossaryGuid, JsonAtlasGlossaryInner updatedGlossary) {
        if (glossaryGuid == null) {
            throw new IllegalArgumentException("Parameter glossaryGuid is required and cannot be null.");
        }
        if (updatedGlossary == null) {
            throw new IllegalArgumentException("Parameter updatedGlossary is required and cannot be null.");
        }
        Validator.validate(updatedGlossary);
        return service.updateGlossary(glossaryGuid, updatedGlossary, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasGlossaryInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasGlossaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasGlossaryInner> clientResponse = updateGlossaryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasGlossaryInner> updateGlossaryDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasGlossaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasGlossaryInner>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteGlossary(String glossaryGuid) {
        deleteGlossaryWithServiceResponseAsync(glossaryGuid).toBlocking().single().body();
    }

    /**
     * Deletes a glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteGlossaryAsync(String glossaryGuid, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteGlossaryWithServiceResponseAsync(glossaryGuid), serviceCallback);
    }

    /**
     * Deletes a glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteGlossaryAsync(String glossaryGuid) {
        return deleteGlossaryWithServiceResponseAsync(glossaryGuid).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteGlossaryWithServiceResponseAsync(String glossaryGuid) {
        if (glossaryGuid == null) {
            throw new IllegalArgumentException("Parameter glossaryGuid is required and cannot be null.");
        }
        return service.deleteGlossary(glossaryGuid, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteGlossaryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteGlossaryDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the categories belonging to a specific glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;JsonAtlasGlossaryCategoryInner&gt; object if successful.
     */
    public List<JsonAtlasGlossaryCategoryInner> getGlossaryCategories(String glossaryGuid) {
        return getGlossaryCategoriesWithServiceResponseAsync(glossaryGuid).toBlocking().single().body();
    }

    /**
     * Gets the categories belonging to a specific glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<JsonAtlasGlossaryCategoryInner>> getGlossaryCategoriesAsync(String glossaryGuid, final ServiceCallback<List<JsonAtlasGlossaryCategoryInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getGlossaryCategoriesWithServiceResponseAsync(glossaryGuid), serviceCallback);
    }

    /**
     * Gets the categories belonging to a specific glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;JsonAtlasGlossaryCategoryInner&gt; object
     */
    public Observable<List<JsonAtlasGlossaryCategoryInner>> getGlossaryCategoriesAsync(String glossaryGuid) {
        return getGlossaryCategoriesWithServiceResponseAsync(glossaryGuid).map(new Func1<ServiceResponse<List<JsonAtlasGlossaryCategoryInner>>, List<JsonAtlasGlossaryCategoryInner>>() {
            @Override
            public List<JsonAtlasGlossaryCategoryInner> call(ServiceResponse<List<JsonAtlasGlossaryCategoryInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the categories belonging to a specific glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;JsonAtlasGlossaryCategoryInner&gt; object
     */
    public Observable<ServiceResponse<List<JsonAtlasGlossaryCategoryInner>>> getGlossaryCategoriesWithServiceResponseAsync(String glossaryGuid) {
        if (glossaryGuid == null) {
            throw new IllegalArgumentException("Parameter glossaryGuid is required and cannot be null.");
        }
        return service.getGlossaryCategories(glossaryGuid, this.client.limit(), this.client.offset(), this.client.sort(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<JsonAtlasGlossaryCategoryInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<JsonAtlasGlossaryCategoryInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<JsonAtlasGlossaryCategoryInner>> clientResponse = getGlossaryCategoriesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<JsonAtlasGlossaryCategoryInner>> getGlossaryCategoriesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<JsonAtlasGlossaryCategoryInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<JsonAtlasGlossaryCategoryInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the category headers belonging to a specific glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;JsonAtlasRelatedCategoryHeaderInner&gt; object if successful.
     */
    public List<JsonAtlasRelatedCategoryHeaderInner> getGlossaryCategoriesHeaders(String glossaryGuid) {
        return getGlossaryCategoriesHeadersWithServiceResponseAsync(glossaryGuid).toBlocking().single().body();
    }

    /**
     * Gets the category headers belonging to a specific glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<JsonAtlasRelatedCategoryHeaderInner>> getGlossaryCategoriesHeadersAsync(String glossaryGuid, final ServiceCallback<List<JsonAtlasRelatedCategoryHeaderInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getGlossaryCategoriesHeadersWithServiceResponseAsync(glossaryGuid), serviceCallback);
    }

    /**
     * Gets the category headers belonging to a specific glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;JsonAtlasRelatedCategoryHeaderInner&gt; object
     */
    public Observable<List<JsonAtlasRelatedCategoryHeaderInner>> getGlossaryCategoriesHeadersAsync(String glossaryGuid) {
        return getGlossaryCategoriesHeadersWithServiceResponseAsync(glossaryGuid).map(new Func1<ServiceResponse<List<JsonAtlasRelatedCategoryHeaderInner>>, List<JsonAtlasRelatedCategoryHeaderInner>>() {
            @Override
            public List<JsonAtlasRelatedCategoryHeaderInner> call(ServiceResponse<List<JsonAtlasRelatedCategoryHeaderInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the category headers belonging to a specific glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;JsonAtlasRelatedCategoryHeaderInner&gt; object
     */
    public Observable<ServiceResponse<List<JsonAtlasRelatedCategoryHeaderInner>>> getGlossaryCategoriesHeadersWithServiceResponseAsync(String glossaryGuid) {
        if (glossaryGuid == null) {
            throw new IllegalArgumentException("Parameter glossaryGuid is required and cannot be null.");
        }
        return service.getGlossaryCategoriesHeaders(glossaryGuid, this.client.limit(), this.client.offset(), this.client.sort(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<JsonAtlasRelatedCategoryHeaderInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<JsonAtlasRelatedCategoryHeaderInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<JsonAtlasRelatedCategoryHeaderInner>> clientResponse = getGlossaryCategoriesHeadersDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<JsonAtlasRelatedCategoryHeaderInner>> getGlossaryCategoriesHeadersDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<JsonAtlasRelatedCategoryHeaderInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<JsonAtlasRelatedCategoryHeaderInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a specific glossary with detailed information.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasGlossaryExtInfoInner object if successful.
     */
    public JsonAtlasGlossaryExtInfoInner getDetailedGlossary(String glossaryGuid) {
        return getDetailedGlossaryWithServiceResponseAsync(glossaryGuid).toBlocking().single().body();
    }

    /**
     * Gets a specific glossary with detailed information.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasGlossaryExtInfoInner> getDetailedGlossaryAsync(String glossaryGuid, final ServiceCallback<JsonAtlasGlossaryExtInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDetailedGlossaryWithServiceResponseAsync(glossaryGuid), serviceCallback);
    }

    /**
     * Gets a specific glossary with detailed information.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryExtInfoInner object
     */
    public Observable<JsonAtlasGlossaryExtInfoInner> getDetailedGlossaryAsync(String glossaryGuid) {
        return getDetailedGlossaryWithServiceResponseAsync(glossaryGuid).map(new Func1<ServiceResponse<JsonAtlasGlossaryExtInfoInner>, JsonAtlasGlossaryExtInfoInner>() {
            @Override
            public JsonAtlasGlossaryExtInfoInner call(ServiceResponse<JsonAtlasGlossaryExtInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a specific glossary with detailed information.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryExtInfoInner object
     */
    public Observable<ServiceResponse<JsonAtlasGlossaryExtInfoInner>> getDetailedGlossaryWithServiceResponseAsync(String glossaryGuid) {
        if (glossaryGuid == null) {
            throw new IllegalArgumentException("Parameter glossaryGuid is required and cannot be null.");
        }
        return service.getDetailedGlossary(glossaryGuid, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasGlossaryExtInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasGlossaryExtInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasGlossaryExtInfoInner> clientResponse = getDetailedGlossaryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasGlossaryExtInfoInner> getDetailedGlossaryDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasGlossaryExtInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasGlossaryExtInfoInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the glossary partially. Some properties such as qualifiedName are not allowed to be updated.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @param partialUpdates A map containing keys as attribute names and values as corresponding attribute values.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasGlossaryInner object if successful.
     */
    public JsonAtlasGlossaryInner partialUpdateGlossary(String glossaryGuid, Map<String, String> partialUpdates) {
        return partialUpdateGlossaryWithServiceResponseAsync(glossaryGuid, partialUpdates).toBlocking().single().body();
    }

    /**
     * Updates the glossary partially. Some properties such as qualifiedName are not allowed to be updated.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @param partialUpdates A map containing keys as attribute names and values as corresponding attribute values.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasGlossaryInner> partialUpdateGlossaryAsync(String glossaryGuid, Map<String, String> partialUpdates, final ServiceCallback<JsonAtlasGlossaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(partialUpdateGlossaryWithServiceResponseAsync(glossaryGuid, partialUpdates), serviceCallback);
    }

    /**
     * Updates the glossary partially. Some properties such as qualifiedName are not allowed to be updated.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @param partialUpdates A map containing keys as attribute names and values as corresponding attribute values.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryInner object
     */
    public Observable<JsonAtlasGlossaryInner> partialUpdateGlossaryAsync(String glossaryGuid, Map<String, String> partialUpdates) {
        return partialUpdateGlossaryWithServiceResponseAsync(glossaryGuid, partialUpdates).map(new Func1<ServiceResponse<JsonAtlasGlossaryInner>, JsonAtlasGlossaryInner>() {
            @Override
            public JsonAtlasGlossaryInner call(ServiceResponse<JsonAtlasGlossaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the glossary partially. Some properties such as qualifiedName are not allowed to be updated.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @param partialUpdates A map containing keys as attribute names and values as corresponding attribute values.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasGlossaryInner object
     */
    public Observable<ServiceResponse<JsonAtlasGlossaryInner>> partialUpdateGlossaryWithServiceResponseAsync(String glossaryGuid, Map<String, String> partialUpdates) {
        if (glossaryGuid == null) {
            throw new IllegalArgumentException("Parameter glossaryGuid is required and cannot be null.");
        }
        if (partialUpdates == null) {
            throw new IllegalArgumentException("Parameter partialUpdates is required and cannot be null.");
        }
        Validator.validate(partialUpdates);
        return service.partialUpdateGlossary(glossaryGuid, partialUpdates, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasGlossaryInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasGlossaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasGlossaryInner> clientResponse = partialUpdateGlossaryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasGlossaryInner> partialUpdateGlossaryDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasGlossaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasGlossaryInner>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets terms belonging to a specific glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;JsonAtlasGlossaryTermInner&gt; object if successful.
     */
    public List<JsonAtlasGlossaryTermInner> getGlossaryTerms(String glossaryGuid) {
        return getGlossaryTermsWithServiceResponseAsync(glossaryGuid).toBlocking().single().body();
    }

    /**
     * Gets terms belonging to a specific glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<JsonAtlasGlossaryTermInner>> getGlossaryTermsAsync(String glossaryGuid, final ServiceCallback<List<JsonAtlasGlossaryTermInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getGlossaryTermsWithServiceResponseAsync(glossaryGuid), serviceCallback);
    }

    /**
     * Gets terms belonging to a specific glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;JsonAtlasGlossaryTermInner&gt; object
     */
    public Observable<List<JsonAtlasGlossaryTermInner>> getGlossaryTermsAsync(String glossaryGuid) {
        return getGlossaryTermsWithServiceResponseAsync(glossaryGuid).map(new Func1<ServiceResponse<List<JsonAtlasGlossaryTermInner>>, List<JsonAtlasGlossaryTermInner>>() {
            @Override
            public List<JsonAtlasGlossaryTermInner> call(ServiceResponse<List<JsonAtlasGlossaryTermInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets terms belonging to a specific glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;JsonAtlasGlossaryTermInner&gt; object
     */
    public Observable<ServiceResponse<List<JsonAtlasGlossaryTermInner>>> getGlossaryTermsWithServiceResponseAsync(String glossaryGuid) {
        if (glossaryGuid == null) {
            throw new IllegalArgumentException("Parameter glossaryGuid is required and cannot be null.");
        }
        return service.getGlossaryTerms(glossaryGuid, this.client.limit(), this.client.offset(), this.client.sort(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<JsonAtlasGlossaryTermInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<JsonAtlasGlossaryTermInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<JsonAtlasGlossaryTermInner>> clientResponse = getGlossaryTermsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<JsonAtlasGlossaryTermInner>> getGlossaryTermsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<JsonAtlasGlossaryTermInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<JsonAtlasGlossaryTermInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets term headers belonging to a specific glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;JsonAtlasRelatedTermHeaderInner&gt; object if successful.
     */
    public List<JsonAtlasRelatedTermHeaderInner> getGlossaryTermHeaders(String glossaryGuid) {
        return getGlossaryTermHeadersWithServiceResponseAsync(glossaryGuid).toBlocking().single().body();
    }

    /**
     * Gets term headers belonging to a specific glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<JsonAtlasRelatedTermHeaderInner>> getGlossaryTermHeadersAsync(String glossaryGuid, final ServiceCallback<List<JsonAtlasRelatedTermHeaderInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getGlossaryTermHeadersWithServiceResponseAsync(glossaryGuid), serviceCallback);
    }

    /**
     * Gets term headers belonging to a specific glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;JsonAtlasRelatedTermHeaderInner&gt; object
     */
    public Observable<List<JsonAtlasRelatedTermHeaderInner>> getGlossaryTermHeadersAsync(String glossaryGuid) {
        return getGlossaryTermHeadersWithServiceResponseAsync(glossaryGuid).map(new Func1<ServiceResponse<List<JsonAtlasRelatedTermHeaderInner>>, List<JsonAtlasRelatedTermHeaderInner>>() {
            @Override
            public List<JsonAtlasRelatedTermHeaderInner> call(ServiceResponse<List<JsonAtlasRelatedTermHeaderInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets term headers belonging to a specific glossary.
     *
     * @param glossaryGuid The globally unique identifier for glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;JsonAtlasRelatedTermHeaderInner&gt; object
     */
    public Observable<ServiceResponse<List<JsonAtlasRelatedTermHeaderInner>>> getGlossaryTermHeadersWithServiceResponseAsync(String glossaryGuid) {
        if (glossaryGuid == null) {
            throw new IllegalArgumentException("Parameter glossaryGuid is required and cannot be null.");
        }
        return service.getGlossaryTermHeaders(glossaryGuid, this.client.limit(), this.client.offset(), this.client.sort(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<JsonAtlasRelatedTermHeaderInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<JsonAtlasRelatedTermHeaderInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<JsonAtlasRelatedTermHeaderInner>> clientResponse = getGlossaryTermHeadersDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<JsonAtlasRelatedTermHeaderInner>> getGlossaryTermHeadersDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<JsonAtlasRelatedTermHeaderInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<JsonAtlasRelatedTermHeaderInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets terms by glossary name.
     *
     * @param glossaryName The name of the glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;JsonAtlasGlossaryTermInner&gt; object if successful.
     */
    public List<JsonAtlasGlossaryTermInner> getTermsByGlossaryName(String glossaryName) {
        return getTermsByGlossaryNameWithServiceResponseAsync(glossaryName).toBlocking().single().body();
    }

    /**
     * Gets terms by glossary name.
     *
     * @param glossaryName The name of the glossary.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<JsonAtlasGlossaryTermInner>> getTermsByGlossaryNameAsync(String glossaryName, final ServiceCallback<List<JsonAtlasGlossaryTermInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getTermsByGlossaryNameWithServiceResponseAsync(glossaryName), serviceCallback);
    }

    /**
     * Gets terms by glossary name.
     *
     * @param glossaryName The name of the glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;JsonAtlasGlossaryTermInner&gt; object
     */
    public Observable<List<JsonAtlasGlossaryTermInner>> getTermsByGlossaryNameAsync(String glossaryName) {
        return getTermsByGlossaryNameWithServiceResponseAsync(glossaryName).map(new Func1<ServiceResponse<List<JsonAtlasGlossaryTermInner>>, List<JsonAtlasGlossaryTermInner>>() {
            @Override
            public List<JsonAtlasGlossaryTermInner> call(ServiceResponse<List<JsonAtlasGlossaryTermInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets terms by glossary name.
     *
     * @param glossaryName The name of the glossary.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;JsonAtlasGlossaryTermInner&gt; object
     */
    public Observable<ServiceResponse<List<JsonAtlasGlossaryTermInner>>> getTermsByGlossaryNameWithServiceResponseAsync(String glossaryName) {
        if (glossaryName == null) {
            throw new IllegalArgumentException("Parameter glossaryName is required and cannot be null.");
        }
        return service.getTermsByGlossaryName(glossaryName, this.client.limit(), this.client.offset(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<JsonAtlasGlossaryTermInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<JsonAtlasGlossaryTermInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<JsonAtlasGlossaryTermInner>> clientResponse = getTermsByGlossaryNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<JsonAtlasGlossaryTermInner>> getTermsByGlossaryNameDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<JsonAtlasGlossaryTermInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<JsonAtlasGlossaryTermInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
