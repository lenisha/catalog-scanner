/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.msft.atlasscanservice.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.CloudException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.Response;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.HTTP;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Path;
import rx.Observable;
import rx.functions.Func1;

/**
 * An instance of this class provides access to all the operations defined
 * in TypesRESTs.
 */
public class TypesRESTsInner {
    /** The Retrofit service to perform REST calls. */
    private TypesRESTsService service;
    /** The service client containing this operation class. */
    private DataCatalogClientImpl client;

    /**
     * Initializes an instance of TypesRESTsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public TypesRESTsInner(Retrofit retrofit, DataCatalogClientImpl client) {
        this.service = retrofit.create(TypesRESTsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for TypesRESTs to be
     * used by Retrofit to perform actually REST calls.
     */
    interface TypesRESTsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.TypesRESTs getClassificationDefByGuid" })
        @GET("v2/types/classificationdef/guid/{guid}")
        Observable<Response<ResponseBody>> getClassificationDefByGuid(@Path("guid") String guid, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.TypesRESTs getClassificationDefByName" })
        @GET("v2/types/classificationdef/name/{name}")
        Observable<Response<ResponseBody>> getClassificationDefByName(@Path("name") String name, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.TypesRESTs getEntityDefByGuid" })
        @GET("v2/types/entitydef/guid/{guid}")
        Observable<Response<ResponseBody>> getEntityDefByGuid(@Path("guid") String guid, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.TypesRESTs getEntityDefByName" })
        @GET("v2/types/entitydef/name/{name}")
        Observable<Response<ResponseBody>> getEntityDefByName(@Path("name") String name, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.TypesRESTs getEnumDefByGuid" })
        @GET("v2/types/enumdef/guid/{guid}")
        Observable<Response<ResponseBody>> getEnumDefByGuid(@Path("guid") String guid, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.TypesRESTs getEnumDefByName" })
        @GET("v2/types/enumdef/name/{name}")
        Observable<Response<ResponseBody>> getEnumDefByName(@Path("name") String name, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.TypesRESTs getRelationshipDefByGuid" })
        @GET("v2/types/relationshipdef/guid/{guid}")
        Observable<Response<ResponseBody>> getRelationshipDefByGuid(@Path("guid") String guid, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.TypesRESTs getRelationshipDefByName" })
        @GET("v2/types/relationshipdef/name/{name}")
        Observable<Response<ResponseBody>> getRelationshipDefByName(@Path("name") String name, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.TypesRESTs getStructDefByGuid" })
        @GET("v2/types/structdef/guid/{guid}")
        Observable<Response<ResponseBody>> getStructDefByGuid(@Path("guid") String guid, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.TypesRESTs getStructDefByName" })
        @GET("v2/types/structdef/name/{name}")
        Observable<Response<ResponseBody>> getStructDefByName(@Path("name") String name, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.TypesRESTs getTypeDefByGuid" })
        @GET("v2/types/typedef/guid/{guid}")
        Observable<Response<ResponseBody>> getTypeDefByGuid(@Path("guid") String guid, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.TypesRESTs getTypeDefByName" })
        @GET("v2/types/typedef/name/{name}")
        Observable<Response<ResponseBody>> getTypeDefByName(@Path("name") String name, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.TypesRESTs getAllTypeDefs" })
        @GET("v2/types/typedefs")
        Observable<Response<ResponseBody>> getAllTypeDefs(@Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.TypesRESTs createAtlasTypeDefs" })
        @POST("v2/types/typedefs")
        Observable<Response<ResponseBody>> createAtlasTypeDefs(@Body JsonAtlasTypesDefInner typesDef, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.TypesRESTs updateAtlasTypeDefs" })
        @PUT("v2/types/typedefs")
        Observable<Response<ResponseBody>> updateAtlasTypeDefs(@Body JsonAtlasTypesDefInner typesDef, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.TypesRESTs deleteAtlasTypeDefs" })
        @HTTP(path = "v2/types/typedefs", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteAtlasTypeDefs(@Body JsonAtlasTypesDefInner typesDef, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.TypesRESTs getTypeDefHeaders" })
        @GET("v2/types/typedefs/headers")
        Observable<Response<ResponseBody>> getTypeDefHeaders(@Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Gets the classification definition for the given GUID.
     *
     * @param guid The globally unique identifier of the classification.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasClassificationDefInner object if successful.
     */
    public JsonAtlasClassificationDefInner getClassificationDefByGuid(String guid) {
        return getClassificationDefByGuidWithServiceResponseAsync(guid).toBlocking().single().body();
    }

    /**
     * Gets the classification definition for the given GUID.
     *
     * @param guid The globally unique identifier of the classification.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasClassificationDefInner> getClassificationDefByGuidAsync(String guid, final ServiceCallback<JsonAtlasClassificationDefInner> serviceCallback) {
        return ServiceFuture.fromResponse(getClassificationDefByGuidWithServiceResponseAsync(guid), serviceCallback);
    }

    /**
     * Gets the classification definition for the given GUID.
     *
     * @param guid The globally unique identifier of the classification.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasClassificationDefInner object
     */
    public Observable<JsonAtlasClassificationDefInner> getClassificationDefByGuidAsync(String guid) {
        return getClassificationDefByGuidWithServiceResponseAsync(guid).map(new Func1<ServiceResponse<JsonAtlasClassificationDefInner>, JsonAtlasClassificationDefInner>() {
            @Override
            public JsonAtlasClassificationDefInner call(ServiceResponse<JsonAtlasClassificationDefInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the classification definition for the given GUID.
     *
     * @param guid The globally unique identifier of the classification.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasClassificationDefInner object
     */
    public Observable<ServiceResponse<JsonAtlasClassificationDefInner>> getClassificationDefByGuidWithServiceResponseAsync(String guid) {
        if (guid == null) {
            throw new IllegalArgumentException("Parameter guid is required and cannot be null.");
        }
        return service.getClassificationDefByGuid(guid, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasClassificationDefInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasClassificationDefInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasClassificationDefInner> clientResponse = getClassificationDefByGuidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasClassificationDefInner> getClassificationDefByGuidDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasClassificationDefInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasClassificationDefInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the classification definition by its name (unique).
     *
     * @param name The name of the classification.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasClassificationDefInner object if successful.
     */
    public JsonAtlasClassificationDefInner getClassificationDefByName(String name) {
        return getClassificationDefByNameWithServiceResponseAsync(name).toBlocking().single().body();
    }

    /**
     * Gets the classification definition by its name (unique).
     *
     * @param name The name of the classification.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasClassificationDefInner> getClassificationDefByNameAsync(String name, final ServiceCallback<JsonAtlasClassificationDefInner> serviceCallback) {
        return ServiceFuture.fromResponse(getClassificationDefByNameWithServiceResponseAsync(name), serviceCallback);
    }

    /**
     * Gets the classification definition by its name (unique).
     *
     * @param name The name of the classification.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasClassificationDefInner object
     */
    public Observable<JsonAtlasClassificationDefInner> getClassificationDefByNameAsync(String name) {
        return getClassificationDefByNameWithServiceResponseAsync(name).map(new Func1<ServiceResponse<JsonAtlasClassificationDefInner>, JsonAtlasClassificationDefInner>() {
            @Override
            public JsonAtlasClassificationDefInner call(ServiceResponse<JsonAtlasClassificationDefInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the classification definition by its name (unique).
     *
     * @param name The name of the classification.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasClassificationDefInner object
     */
    public Observable<ServiceResponse<JsonAtlasClassificationDefInner>> getClassificationDefByNameWithServiceResponseAsync(String name) {
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        return service.getClassificationDefByName(name, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasClassificationDefInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasClassificationDefInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasClassificationDefInner> clientResponse = getClassificationDefByNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasClassificationDefInner> getClassificationDefByNameDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasClassificationDefInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasClassificationDefInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the Entity definition for the given GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasEntityDefInner object if successful.
     */
    public JsonAtlasEntityDefInner getEntityDefByGuid(String guid) {
        return getEntityDefByGuidWithServiceResponseAsync(guid).toBlocking().single().body();
    }

    /**
     * Gets the Entity definition for the given GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasEntityDefInner> getEntityDefByGuidAsync(String guid, final ServiceCallback<JsonAtlasEntityDefInner> serviceCallback) {
        return ServiceFuture.fromResponse(getEntityDefByGuidWithServiceResponseAsync(guid), serviceCallback);
    }

    /**
     * Gets the Entity definition for the given GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasEntityDefInner object
     */
    public Observable<JsonAtlasEntityDefInner> getEntityDefByGuidAsync(String guid) {
        return getEntityDefByGuidWithServiceResponseAsync(guid).map(new Func1<ServiceResponse<JsonAtlasEntityDefInner>, JsonAtlasEntityDefInner>() {
            @Override
            public JsonAtlasEntityDefInner call(ServiceResponse<JsonAtlasEntityDefInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Entity definition for the given GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasEntityDefInner object
     */
    public Observable<ServiceResponse<JsonAtlasEntityDefInner>> getEntityDefByGuidWithServiceResponseAsync(String guid) {
        if (guid == null) {
            throw new IllegalArgumentException("Parameter guid is required and cannot be null.");
        }
        return service.getEntityDefByGuid(guid, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasEntityDefInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasEntityDefInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasEntityDefInner> clientResponse = getEntityDefByGuidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasEntityDefInner> getEntityDefByGuidDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasEntityDefInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasEntityDefInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the entity definition by its name (unique).
     *
     * @param name The name of the entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasEntityDefInner object if successful.
     */
    public JsonAtlasEntityDefInner getEntityDefByName(String name) {
        return getEntityDefByNameWithServiceResponseAsync(name).toBlocking().single().body();
    }

    /**
     * Gets the entity definition by its name (unique).
     *
     * @param name The name of the entity.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasEntityDefInner> getEntityDefByNameAsync(String name, final ServiceCallback<JsonAtlasEntityDefInner> serviceCallback) {
        return ServiceFuture.fromResponse(getEntityDefByNameWithServiceResponseAsync(name), serviceCallback);
    }

    /**
     * Gets the entity definition by its name (unique).
     *
     * @param name The name of the entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasEntityDefInner object
     */
    public Observable<JsonAtlasEntityDefInner> getEntityDefByNameAsync(String name) {
        return getEntityDefByNameWithServiceResponseAsync(name).map(new Func1<ServiceResponse<JsonAtlasEntityDefInner>, JsonAtlasEntityDefInner>() {
            @Override
            public JsonAtlasEntityDefInner call(ServiceResponse<JsonAtlasEntityDefInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the entity definition by its name (unique).
     *
     * @param name The name of the entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasEntityDefInner object
     */
    public Observable<ServiceResponse<JsonAtlasEntityDefInner>> getEntityDefByNameWithServiceResponseAsync(String name) {
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        return service.getEntityDefByName(name, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasEntityDefInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasEntityDefInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasEntityDefInner> clientResponse = getEntityDefByNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasEntityDefInner> getEntityDefByNameDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasEntityDefInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasEntityDefInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the enum definition for the given GUID.
     *
     * @param guid The globally unique identifier of the enum.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasEnumDefInner object if successful.
     */
    public JsonAtlasEnumDefInner getEnumDefByGuid(String guid) {
        return getEnumDefByGuidWithServiceResponseAsync(guid).toBlocking().single().body();
    }

    /**
     * Gets the enum definition for the given GUID.
     *
     * @param guid The globally unique identifier of the enum.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasEnumDefInner> getEnumDefByGuidAsync(String guid, final ServiceCallback<JsonAtlasEnumDefInner> serviceCallback) {
        return ServiceFuture.fromResponse(getEnumDefByGuidWithServiceResponseAsync(guid), serviceCallback);
    }

    /**
     * Gets the enum definition for the given GUID.
     *
     * @param guid The globally unique identifier of the enum.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasEnumDefInner object
     */
    public Observable<JsonAtlasEnumDefInner> getEnumDefByGuidAsync(String guid) {
        return getEnumDefByGuidWithServiceResponseAsync(guid).map(new Func1<ServiceResponse<JsonAtlasEnumDefInner>, JsonAtlasEnumDefInner>() {
            @Override
            public JsonAtlasEnumDefInner call(ServiceResponse<JsonAtlasEnumDefInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the enum definition for the given GUID.
     *
     * @param guid The globally unique identifier of the enum.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasEnumDefInner object
     */
    public Observable<ServiceResponse<JsonAtlasEnumDefInner>> getEnumDefByGuidWithServiceResponseAsync(String guid) {
        if (guid == null) {
            throw new IllegalArgumentException("Parameter guid is required and cannot be null.");
        }
        return service.getEnumDefByGuid(guid, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasEnumDefInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasEnumDefInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasEnumDefInner> clientResponse = getEnumDefByGuidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasEnumDefInner> getEnumDefByGuidDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasEnumDefInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasEnumDefInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the enum definition by its name (unique).
     *
     * @param name The name of the enum.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasEnumDefInner object if successful.
     */
    public JsonAtlasEnumDefInner getEnumDefByName(String name) {
        return getEnumDefByNameWithServiceResponseAsync(name).toBlocking().single().body();
    }

    /**
     * Gets the enum definition by its name (unique).
     *
     * @param name The name of the enum.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasEnumDefInner> getEnumDefByNameAsync(String name, final ServiceCallback<JsonAtlasEnumDefInner> serviceCallback) {
        return ServiceFuture.fromResponse(getEnumDefByNameWithServiceResponseAsync(name), serviceCallback);
    }

    /**
     * Gets the enum definition by its name (unique).
     *
     * @param name The name of the enum.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasEnumDefInner object
     */
    public Observable<JsonAtlasEnumDefInner> getEnumDefByNameAsync(String name) {
        return getEnumDefByNameWithServiceResponseAsync(name).map(new Func1<ServiceResponse<JsonAtlasEnumDefInner>, JsonAtlasEnumDefInner>() {
            @Override
            public JsonAtlasEnumDefInner call(ServiceResponse<JsonAtlasEnumDefInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the enum definition by its name (unique).
     *
     * @param name The name of the enum.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasEnumDefInner object
     */
    public Observable<ServiceResponse<JsonAtlasEnumDefInner>> getEnumDefByNameWithServiceResponseAsync(String name) {
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        return service.getEnumDefByName(name, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasEnumDefInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasEnumDefInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasEnumDefInner> clientResponse = getEnumDefByNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasEnumDefInner> getEnumDefByNameDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasEnumDefInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasEnumDefInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the relationship definition for the given GUID.
     *
     * @param guid The globally unique identifier of the relationship.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasRelationshipDefInner object if successful.
     */
    public JsonAtlasRelationshipDefInner getRelationshipDefByGuid(String guid) {
        return getRelationshipDefByGuidWithServiceResponseAsync(guid).toBlocking().single().body();
    }

    /**
     * Gets the relationship definition for the given GUID.
     *
     * @param guid The globally unique identifier of the relationship.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasRelationshipDefInner> getRelationshipDefByGuidAsync(String guid, final ServiceCallback<JsonAtlasRelationshipDefInner> serviceCallback) {
        return ServiceFuture.fromResponse(getRelationshipDefByGuidWithServiceResponseAsync(guid), serviceCallback);
    }

    /**
     * Gets the relationship definition for the given GUID.
     *
     * @param guid The globally unique identifier of the relationship.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasRelationshipDefInner object
     */
    public Observable<JsonAtlasRelationshipDefInner> getRelationshipDefByGuidAsync(String guid) {
        return getRelationshipDefByGuidWithServiceResponseAsync(guid).map(new Func1<ServiceResponse<JsonAtlasRelationshipDefInner>, JsonAtlasRelationshipDefInner>() {
            @Override
            public JsonAtlasRelationshipDefInner call(ServiceResponse<JsonAtlasRelationshipDefInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the relationship definition for the given GUID.
     *
     * @param guid The globally unique identifier of the relationship.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasRelationshipDefInner object
     */
    public Observable<ServiceResponse<JsonAtlasRelationshipDefInner>> getRelationshipDefByGuidWithServiceResponseAsync(String guid) {
        if (guid == null) {
            throw new IllegalArgumentException("Parameter guid is required and cannot be null.");
        }
        return service.getRelationshipDefByGuid(guid, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasRelationshipDefInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasRelationshipDefInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasRelationshipDefInner> clientResponse = getRelationshipDefByGuidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasRelationshipDefInner> getRelationshipDefByGuidDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasRelationshipDefInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasRelationshipDefInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the relationship definition by its name (unique).
     *
     * @param name The name of the relationship.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasRelationshipDefInner object if successful.
     */
    public JsonAtlasRelationshipDefInner getRelationshipDefByName(String name) {
        return getRelationshipDefByNameWithServiceResponseAsync(name).toBlocking().single().body();
    }

    /**
     * Gets the relationship definition by its name (unique).
     *
     * @param name The name of the relationship.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasRelationshipDefInner> getRelationshipDefByNameAsync(String name, final ServiceCallback<JsonAtlasRelationshipDefInner> serviceCallback) {
        return ServiceFuture.fromResponse(getRelationshipDefByNameWithServiceResponseAsync(name), serviceCallback);
    }

    /**
     * Gets the relationship definition by its name (unique).
     *
     * @param name The name of the relationship.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasRelationshipDefInner object
     */
    public Observable<JsonAtlasRelationshipDefInner> getRelationshipDefByNameAsync(String name) {
        return getRelationshipDefByNameWithServiceResponseAsync(name).map(new Func1<ServiceResponse<JsonAtlasRelationshipDefInner>, JsonAtlasRelationshipDefInner>() {
            @Override
            public JsonAtlasRelationshipDefInner call(ServiceResponse<JsonAtlasRelationshipDefInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the relationship definition by its name (unique).
     *
     * @param name The name of the relationship.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasRelationshipDefInner object
     */
    public Observable<ServiceResponse<JsonAtlasRelationshipDefInner>> getRelationshipDefByNameWithServiceResponseAsync(String name) {
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        return service.getRelationshipDefByName(name, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasRelationshipDefInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasRelationshipDefInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasRelationshipDefInner> clientResponse = getRelationshipDefByNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasRelationshipDefInner> getRelationshipDefByNameDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasRelationshipDefInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasRelationshipDefInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the struct definition for the given GUID.
     *
     * @param guid The globally unique identifier of the struct.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasStructDefInner object if successful.
     */
    public JsonAtlasStructDefInner getStructDefByGuid(String guid) {
        return getStructDefByGuidWithServiceResponseAsync(guid).toBlocking().single().body();
    }

    /**
     * Gets the struct definition for the given GUID.
     *
     * @param guid The globally unique identifier of the struct.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasStructDefInner> getStructDefByGuidAsync(String guid, final ServiceCallback<JsonAtlasStructDefInner> serviceCallback) {
        return ServiceFuture.fromResponse(getStructDefByGuidWithServiceResponseAsync(guid), serviceCallback);
    }

    /**
     * Gets the struct definition for the given GUID.
     *
     * @param guid The globally unique identifier of the struct.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasStructDefInner object
     */
    public Observable<JsonAtlasStructDefInner> getStructDefByGuidAsync(String guid) {
        return getStructDefByGuidWithServiceResponseAsync(guid).map(new Func1<ServiceResponse<JsonAtlasStructDefInner>, JsonAtlasStructDefInner>() {
            @Override
            public JsonAtlasStructDefInner call(ServiceResponse<JsonAtlasStructDefInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the struct definition for the given GUID.
     *
     * @param guid The globally unique identifier of the struct.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasStructDefInner object
     */
    public Observable<ServiceResponse<JsonAtlasStructDefInner>> getStructDefByGuidWithServiceResponseAsync(String guid) {
        if (guid == null) {
            throw new IllegalArgumentException("Parameter guid is required and cannot be null.");
        }
        return service.getStructDefByGuid(guid, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasStructDefInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasStructDefInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasStructDefInner> clientResponse = getStructDefByGuidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasStructDefInner> getStructDefByGuidDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasStructDefInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasStructDefInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the struct definition by its name (unique).
     *
     * @param name The name of the struct.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasStructDefInner object if successful.
     */
    public JsonAtlasStructDefInner getStructDefByName(String name) {
        return getStructDefByNameWithServiceResponseAsync(name).toBlocking().single().body();
    }

    /**
     * Gets the struct definition by its name (unique).
     *
     * @param name The name of the struct.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasStructDefInner> getStructDefByNameAsync(String name, final ServiceCallback<JsonAtlasStructDefInner> serviceCallback) {
        return ServiceFuture.fromResponse(getStructDefByNameWithServiceResponseAsync(name), serviceCallback);
    }

    /**
     * Gets the struct definition by its name (unique).
     *
     * @param name The name of the struct.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasStructDefInner object
     */
    public Observable<JsonAtlasStructDefInner> getStructDefByNameAsync(String name) {
        return getStructDefByNameWithServiceResponseAsync(name).map(new Func1<ServiceResponse<JsonAtlasStructDefInner>, JsonAtlasStructDefInner>() {
            @Override
            public JsonAtlasStructDefInner call(ServiceResponse<JsonAtlasStructDefInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the struct definition by its name (unique).
     *
     * @param name The name of the struct.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasStructDefInner object
     */
    public Observable<ServiceResponse<JsonAtlasStructDefInner>> getStructDefByNameWithServiceResponseAsync(String name) {
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        return service.getStructDefByName(name, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasStructDefInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasStructDefInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasStructDefInner> clientResponse = getStructDefByNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasStructDefInner> getStructDefByNameDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasStructDefInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasStructDefInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the type definition for the given GUID.
     *
     * @param guid The globally unique identifier of the type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasBaseTypeDefInner object if successful.
     */
    public JsonAtlasBaseTypeDefInner getTypeDefByGuid(String guid) {
        return getTypeDefByGuidWithServiceResponseAsync(guid).toBlocking().single().body();
    }

    /**
     * Gets the type definition for the given GUID.
     *
     * @param guid The globally unique identifier of the type.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasBaseTypeDefInner> getTypeDefByGuidAsync(String guid, final ServiceCallback<JsonAtlasBaseTypeDefInner> serviceCallback) {
        return ServiceFuture.fromResponse(getTypeDefByGuidWithServiceResponseAsync(guid), serviceCallback);
    }

    /**
     * Gets the type definition for the given GUID.
     *
     * @param guid The globally unique identifier of the type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasBaseTypeDefInner object
     */
    public Observable<JsonAtlasBaseTypeDefInner> getTypeDefByGuidAsync(String guid) {
        return getTypeDefByGuidWithServiceResponseAsync(guid).map(new Func1<ServiceResponse<JsonAtlasBaseTypeDefInner>, JsonAtlasBaseTypeDefInner>() {
            @Override
            public JsonAtlasBaseTypeDefInner call(ServiceResponse<JsonAtlasBaseTypeDefInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the type definition for the given GUID.
     *
     * @param guid The globally unique identifier of the type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasBaseTypeDefInner object
     */
    public Observable<ServiceResponse<JsonAtlasBaseTypeDefInner>> getTypeDefByGuidWithServiceResponseAsync(String guid) {
        if (guid == null) {
            throw new IllegalArgumentException("Parameter guid is required and cannot be null.");
        }
        return service.getTypeDefByGuid(guid, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasBaseTypeDefInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasBaseTypeDefInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasBaseTypeDefInner> clientResponse = getTypeDefByGuidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasBaseTypeDefInner> getTypeDefByGuidDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasBaseTypeDefInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasBaseTypeDefInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the type definition by its name (unique).
     *
     * @param name The name of the type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasBaseTypeDefInner object if successful.
     */
    public JsonAtlasBaseTypeDefInner getTypeDefByName(String name) {
        return getTypeDefByNameWithServiceResponseAsync(name).toBlocking().single().body();
    }

    /**
     * Gets the type definition by its name (unique).
     *
     * @param name The name of the type.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasBaseTypeDefInner> getTypeDefByNameAsync(String name, final ServiceCallback<JsonAtlasBaseTypeDefInner> serviceCallback) {
        return ServiceFuture.fromResponse(getTypeDefByNameWithServiceResponseAsync(name), serviceCallback);
    }

    /**
     * Gets the type definition by its name (unique).
     *
     * @param name The name of the type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasBaseTypeDefInner object
     */
    public Observable<JsonAtlasBaseTypeDefInner> getTypeDefByNameAsync(String name) {
        return getTypeDefByNameWithServiceResponseAsync(name).map(new Func1<ServiceResponse<JsonAtlasBaseTypeDefInner>, JsonAtlasBaseTypeDefInner>() {
            @Override
            public JsonAtlasBaseTypeDefInner call(ServiceResponse<JsonAtlasBaseTypeDefInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the type definition by its name (unique).
     *
     * @param name The name of the type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasBaseTypeDefInner object
     */
    public Observable<ServiceResponse<JsonAtlasBaseTypeDefInner>> getTypeDefByNameWithServiceResponseAsync(String name) {
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        return service.getTypeDefByName(name, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasBaseTypeDefInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasBaseTypeDefInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasBaseTypeDefInner> clientResponse = getTypeDefByNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasBaseTypeDefInner> getTypeDefByNameDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasBaseTypeDefInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasBaseTypeDefInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all type definitions in Atlas in bulk.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasTypesDefInner object if successful.
     */
    public JsonAtlasTypesDefInner getAllTypeDefs() {
        return getAllTypeDefsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets all type definitions in Atlas in bulk.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasTypesDefInner> getAllTypeDefsAsync(final ServiceCallback<JsonAtlasTypesDefInner> serviceCallback) {
        return ServiceFuture.fromResponse(getAllTypeDefsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets all type definitions in Atlas in bulk.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasTypesDefInner object
     */
    public Observable<JsonAtlasTypesDefInner> getAllTypeDefsAsync() {
        return getAllTypeDefsWithServiceResponseAsync().map(new Func1<ServiceResponse<JsonAtlasTypesDefInner>, JsonAtlasTypesDefInner>() {
            @Override
            public JsonAtlasTypesDefInner call(ServiceResponse<JsonAtlasTypesDefInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all type definitions in Atlas in bulk.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasTypesDefInner object
     */
    public Observable<ServiceResponse<JsonAtlasTypesDefInner>> getAllTypeDefsWithServiceResponseAsync() {
        return service.getAllTypeDefs(this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasTypesDefInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasTypesDefInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasTypesDefInner> clientResponse = getAllTypeDefsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasTypesDefInner> getAllTypeDefsDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasTypesDefInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasTypesDefInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates all atlas type definitions in bulk, only new definitions will be created.
     Any changes to the existing definitions will be discarded.
     *
     * @param typesDef A composite wrapper object with corresponding lists of the type definition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasTypesDefInner object if successful.
     */
    public JsonAtlasTypesDefInner createAtlasTypeDefs(JsonAtlasTypesDefInner typesDef) {
        return createAtlasTypeDefsWithServiceResponseAsync(typesDef).toBlocking().single().body();
    }

    /**
     * Creates all atlas type definitions in bulk, only new definitions will be created.
     Any changes to the existing definitions will be discarded.
     *
     * @param typesDef A composite wrapper object with corresponding lists of the type definition.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasTypesDefInner> createAtlasTypeDefsAsync(JsonAtlasTypesDefInner typesDef, final ServiceCallback<JsonAtlasTypesDefInner> serviceCallback) {
        return ServiceFuture.fromResponse(createAtlasTypeDefsWithServiceResponseAsync(typesDef), serviceCallback);
    }

    /**
     * Creates all atlas type definitions in bulk, only new definitions will be created.
     Any changes to the existing definitions will be discarded.
     *
     * @param typesDef A composite wrapper object with corresponding lists of the type definition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasTypesDefInner object
     */
    public Observable<JsonAtlasTypesDefInner> createAtlasTypeDefsAsync(JsonAtlasTypesDefInner typesDef) {
        return createAtlasTypeDefsWithServiceResponseAsync(typesDef).map(new Func1<ServiceResponse<JsonAtlasTypesDefInner>, JsonAtlasTypesDefInner>() {
            @Override
            public JsonAtlasTypesDefInner call(ServiceResponse<JsonAtlasTypesDefInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates all atlas type definitions in bulk, only new definitions will be created.
     Any changes to the existing definitions will be discarded.
     *
     * @param typesDef A composite wrapper object with corresponding lists of the type definition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasTypesDefInner object
     */
    public Observable<ServiceResponse<JsonAtlasTypesDefInner>> createAtlasTypeDefsWithServiceResponseAsync(JsonAtlasTypesDefInner typesDef) {
        if (typesDef == null) {
            throw new IllegalArgumentException("Parameter typesDef is required and cannot be null.");
        }
        Validator.validate(typesDef);
        return service.createAtlasTypeDefs(typesDef, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasTypesDefInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasTypesDefInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasTypesDefInner> clientResponse = createAtlasTypeDefsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasTypesDefInner> createAtlasTypeDefsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasTypesDefInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasTypesDefInner>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates all types in bulk, changes detected in the type definitions would be persisted.
     *
     * @param typesDef A composite object that captures all type definition changes.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasTypesDefInner object if successful.
     */
    public JsonAtlasTypesDefInner updateAtlasTypeDefs(JsonAtlasTypesDefInner typesDef) {
        return updateAtlasTypeDefsWithServiceResponseAsync(typesDef).toBlocking().single().body();
    }

    /**
     * Updates all types in bulk, changes detected in the type definitions would be persisted.
     *
     * @param typesDef A composite object that captures all type definition changes.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasTypesDefInner> updateAtlasTypeDefsAsync(JsonAtlasTypesDefInner typesDef, final ServiceCallback<JsonAtlasTypesDefInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateAtlasTypeDefsWithServiceResponseAsync(typesDef), serviceCallback);
    }

    /**
     * Updates all types in bulk, changes detected in the type definitions would be persisted.
     *
     * @param typesDef A composite object that captures all type definition changes.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasTypesDefInner object
     */
    public Observable<JsonAtlasTypesDefInner> updateAtlasTypeDefsAsync(JsonAtlasTypesDefInner typesDef) {
        return updateAtlasTypeDefsWithServiceResponseAsync(typesDef).map(new Func1<ServiceResponse<JsonAtlasTypesDefInner>, JsonAtlasTypesDefInner>() {
            @Override
            public JsonAtlasTypesDefInner call(ServiceResponse<JsonAtlasTypesDefInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates all types in bulk, changes detected in the type definitions would be persisted.
     *
     * @param typesDef A composite object that captures all type definition changes.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasTypesDefInner object
     */
    public Observable<ServiceResponse<JsonAtlasTypesDefInner>> updateAtlasTypeDefsWithServiceResponseAsync(JsonAtlasTypesDefInner typesDef) {
        if (typesDef == null) {
            throw new IllegalArgumentException("Parameter typesDef is required and cannot be null.");
        }
        Validator.validate(typesDef);
        return service.updateAtlasTypeDefs(typesDef, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasTypesDefInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasTypesDefInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasTypesDefInner> clientResponse = updateAtlasTypeDefsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasTypesDefInner> updateAtlasTypeDefsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasTypesDefInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasTypesDefInner>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes API for all types in bulk.
     *
     * @param typesDef A composite object that captures all types to be deleted
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteAtlasTypeDefs(JsonAtlasTypesDefInner typesDef) {
        deleteAtlasTypeDefsWithServiceResponseAsync(typesDef).toBlocking().single().body();
    }

    /**
     * Deletes API for all types in bulk.
     *
     * @param typesDef A composite object that captures all types to be deleted
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAtlasTypeDefsAsync(JsonAtlasTypesDefInner typesDef, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteAtlasTypeDefsWithServiceResponseAsync(typesDef), serviceCallback);
    }

    /**
     * Deletes API for all types in bulk.
     *
     * @param typesDef A composite object that captures all types to be deleted
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAtlasTypeDefsAsync(JsonAtlasTypesDefInner typesDef) {
        return deleteAtlasTypeDefsWithServiceResponseAsync(typesDef).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes API for all types in bulk.
     *
     * @param typesDef A composite object that captures all types to be deleted
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteAtlasTypeDefsWithServiceResponseAsync(JsonAtlasTypesDefInner typesDef) {
        if (typesDef == null) {
            throw new IllegalArgumentException("Parameter typesDef is required and cannot be null.");
        }
        Validator.validate(typesDef);
        return service.deleteAtlasTypeDefs(typesDef, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteAtlasTypeDefsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteAtlasTypeDefsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists all type definitions returned as a list of minimal information header.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;JsonAtlasTypeDefHeaderInner&gt; object if successful.
     */
    public List<JsonAtlasTypeDefHeaderInner> getTypeDefHeaders() {
        return getTypeDefHeadersWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Lists all type definitions returned as a list of minimal information header.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<JsonAtlasTypeDefHeaderInner>> getTypeDefHeadersAsync(final ServiceCallback<List<JsonAtlasTypeDefHeaderInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getTypeDefHeadersWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Lists all type definitions returned as a list of minimal information header.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;JsonAtlasTypeDefHeaderInner&gt; object
     */
    public Observable<List<JsonAtlasTypeDefHeaderInner>> getTypeDefHeadersAsync() {
        return getTypeDefHeadersWithServiceResponseAsync().map(new Func1<ServiceResponse<List<JsonAtlasTypeDefHeaderInner>>, List<JsonAtlasTypeDefHeaderInner>>() {
            @Override
            public List<JsonAtlasTypeDefHeaderInner> call(ServiceResponse<List<JsonAtlasTypeDefHeaderInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Lists all type definitions returned as a list of minimal information header.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;JsonAtlasTypeDefHeaderInner&gt; object
     */
    public Observable<ServiceResponse<List<JsonAtlasTypeDefHeaderInner>>> getTypeDefHeadersWithServiceResponseAsync() {
        return service.getTypeDefHeaders(this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<JsonAtlasTypeDefHeaderInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<JsonAtlasTypeDefHeaderInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<JsonAtlasTypeDefHeaderInner>> clientResponse = getTypeDefHeadersDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<JsonAtlasTypeDefHeaderInner>> getTypeDefHeadersDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<JsonAtlasTypeDefHeaderInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<JsonAtlasTypeDefHeaderInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
