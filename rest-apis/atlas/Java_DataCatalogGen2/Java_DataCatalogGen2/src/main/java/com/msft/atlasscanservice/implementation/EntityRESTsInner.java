/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.msft.atlasscanservice.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.CloudException;
import com.microsoft.rest.CollectionFormat;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import com.msft.atlasscanservice.JsonAtlasObjectIdWithParentGuid;
import com.msft.atlasscanservice.JsonClassificationAssociateRequest;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.Response;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.HTTP;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Path;
import retrofit2.http.Query;
import rx.Observable;
import rx.functions.Func1;

/**
 * An instance of this class provides access to all the operations defined
 * in EntityRESTs.
 */
public class EntityRESTsInner {
    /** The Retrofit service to perform REST calls. */
    private EntityRESTsService service;
    /** The service client containing this operation class. */
    private DataCatalogClientImpl client;

    /**
     * Initializes an instance of EntityRESTsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public EntityRESTsInner(Retrofit retrofit, DataCatalogClientImpl client) {
        this.service = retrofit.create(EntityRESTsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for EntityRESTs to be
     * used by Retrofit to perform actually REST calls.
     */
    interface EntityRESTsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.EntityRESTs createOrUpdate" })
        @POST("v2/entity")
        Observable<Response<ResponseBody>> createOrUpdate(@Body JsonAtlasEntityWithExtInfoInner entity, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.EntityRESTs getByGuids" })
        @GET("v2/entity/bulk")
        Observable<Response<ResponseBody>> getByGuids(@Query("guid") String guid, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.EntityRESTs createOrUpdateBulk" })
        @POST("v2/entity/bulk")
        Observable<Response<ResponseBody>> createOrUpdateBulk(@Body JsonAtlasEntitiesWithExtInfoInner entities, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.EntityRESTs bulkDelete" })
        @HTTP(path = "v2/entity/bulk", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> bulkDelete(@Query("guid") String guid, @Body List<JsonAtlasObjectIdWithParentGuid> atlasObjectIdWithParentGuidList, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.EntityRESTs addClassification" })
        @POST("v2/entity/bulk/classification")
        Observable<Response<ResponseBody>> addClassification(@Body JsonClassificationAssociateRequest request, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.EntityRESTs getById" })
        @GET("v2/entity/guid/{guid}")
        Observable<Response<ResponseBody>> getById(@Path("guid") String guid, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.EntityRESTs partialUpdateEntityAttrByGuid" })
        @PUT("v2/entity/guid/{guid}")
        Observable<Response<ResponseBody>> partialUpdateEntityAttrByGuid(@Path("guid") String guid, @Query("name") String name, @Body Object body, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.EntityRESTs deleteByGuid" })
        @HTTP(path = "v2/entity/guid/{guid}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteByGuid(@Path("guid") String guid, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.EntityRESTs getClassification" })
        @GET("v2/entity/guid/{guid}/classification/{classificationName}")
        Observable<Response<ResponseBody>> getClassification(@Path("guid") String guid, @Path("classificationName") String classificationName, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.EntityRESTs deleteClassification" })
        @HTTP(path = "v2/entity/guid/{guid}/classification/{classificationName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteClassification(@Path("guid") String guid, @Path("classificationName") String classificationName, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.EntityRESTs getClassifications" })
        @GET("v2/entity/guid/{guid}/classifications")
        Observable<Response<ResponseBody>> getClassifications(@Path("guid") String guid, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.EntityRESTs addClassifications" })
        @POST("v2/entity/guid/{guid}/classifications")
        Observable<Response<ResponseBody>> addClassifications(@Path("guid") String guid, @Body List<JsonAtlasClassificationInner> classifications, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.EntityRESTs updateClassifications" })
        @PUT("v2/entity/guid/{guid}/classifications")
        Observable<Response<ResponseBody>> updateClassifications(@Path("guid") String guid, @Body List<JsonAtlasClassificationInner> classifications, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.EntityRESTs getByUniqueAttributes" })
        @GET("v2/entity/uniqueAttribute/type/{typeName}")
        Observable<Response<ResponseBody>> getByUniqueAttributes(@Path("typeName") String typeName, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.EntityRESTs partialUpdateEntityByUniqueAttrs" })
        @PUT("v2/entity/uniqueAttribute/type/{typeName}")
        Observable<Response<ResponseBody>> partialUpdateEntityByUniqueAttrs(@Path("typeName") String typeName, @Body JsonAtlasEntityWithExtInfoInner atlasEntityWithExtInfo, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.EntityRESTs deleteByUniqueAttribute" })
        @HTTP(path = "v2/entity/uniqueAttribute/type/{typeName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteByUniqueAttribute(@Path("typeName") String typeName, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.EntityRESTs deleteClassificationByUniqueAttribute" })
        @HTTP(path = "v2/entity/uniqueAttribute/type/{typeName}/classification/{classificationName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteClassificationByUniqueAttribute(@Path("typeName") String typeName, @Path("classificationName") String classificationName, @Query("parentEntityGuid") String parentEntityGuid, @Query("attr:qualifiedName") String attrqualifiedName, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.EntityRESTs addClassificationsByUniqueAttribute" })
        @POST("v2/entity/uniqueAttribute/type/{typeName}/classifications")
        Observable<Response<ResponseBody>> addClassificationsByUniqueAttribute(@Path("typeName") String typeName, @Body List<JsonAtlasClassificationInner> atlasClassificationArray, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.msft.atlasscanservice.EntityRESTs updateClassificationsByUniqueAttribute" })
        @PUT("v2/entity/uniqueAttribute/type/{typeName}/classifications")
        Observable<Response<ResponseBody>> updateClassificationsByUniqueAttribute(@Path("typeName") String typeName, @Body List<JsonAtlasClassificationInner> atlasClassificationArray, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Creates or updates an entity in Atlas.
     Existing entity is matched using its unique guid if supplied or by its unique attributes eg: qualifiedName.
     Map and array of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string, int&gt;&gt;.
     *
     * @param entity Atlas entity with extended information.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonEntityMutationResponseInner object if successful.
     */
    public JsonEntityMutationResponseInner createOrUpdate(JsonAtlasEntityWithExtInfoInner entity) {
        return createOrUpdateWithServiceResponseAsync(entity).toBlocking().single().body();
    }

    /**
     * Creates or updates an entity in Atlas.
     Existing entity is matched using its unique guid if supplied or by its unique attributes eg: qualifiedName.
     Map and array of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string, int&gt;&gt;.
     *
     * @param entity Atlas entity with extended information.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonEntityMutationResponseInner> createOrUpdateAsync(JsonAtlasEntityWithExtInfoInner entity, final ServiceCallback<JsonEntityMutationResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateWithServiceResponseAsync(entity), serviceCallback);
    }

    /**
     * Creates or updates an entity in Atlas.
     Existing entity is matched using its unique guid if supplied or by its unique attributes eg: qualifiedName.
     Map and array of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string, int&gt;&gt;.
     *
     * @param entity Atlas entity with extended information.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonEntityMutationResponseInner object
     */
    public Observable<JsonEntityMutationResponseInner> createOrUpdateAsync(JsonAtlasEntityWithExtInfoInner entity) {
        return createOrUpdateWithServiceResponseAsync(entity).map(new Func1<ServiceResponse<JsonEntityMutationResponseInner>, JsonEntityMutationResponseInner>() {
            @Override
            public JsonEntityMutationResponseInner call(ServiceResponse<JsonEntityMutationResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates or updates an entity in Atlas.
     Existing entity is matched using its unique guid if supplied or by its unique attributes eg: qualifiedName.
     Map and array of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string, int&gt;&gt;.
     *
     * @param entity Atlas entity with extended information.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonEntityMutationResponseInner object
     */
    public Observable<ServiceResponse<JsonEntityMutationResponseInner>> createOrUpdateWithServiceResponseAsync(JsonAtlasEntityWithExtInfoInner entity) {
        if (entity == null) {
            throw new IllegalArgumentException("Parameter entity is required and cannot be null.");
        }
        Validator.validate(entity);
        return service.createOrUpdate(entity, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonEntityMutationResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonEntityMutationResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonEntityMutationResponseInner> clientResponse = createOrUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonEntityMutationResponseInner> createOrUpdateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonEntityMutationResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonEntityMutationResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists entities in bulk identified by its GUIDs.
     *
     * @param guid An array of GUIDs of entities to create.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasEntitiesWithExtInfoInner object if successful.
     */
    public JsonAtlasEntitiesWithExtInfoInner getByGuids(List<String> guid) {
        return getByGuidsWithServiceResponseAsync(guid).toBlocking().single().body();
    }

    /**
     * Lists entities in bulk identified by its GUIDs.
     *
     * @param guid An array of GUIDs of entities to create.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasEntitiesWithExtInfoInner> getByGuidsAsync(List<String> guid, final ServiceCallback<JsonAtlasEntitiesWithExtInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getByGuidsWithServiceResponseAsync(guid), serviceCallback);
    }

    /**
     * Lists entities in bulk identified by its GUIDs.
     *
     * @param guid An array of GUIDs of entities to create.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasEntitiesWithExtInfoInner object
     */
    public Observable<JsonAtlasEntitiesWithExtInfoInner> getByGuidsAsync(List<String> guid) {
        return getByGuidsWithServiceResponseAsync(guid).map(new Func1<ServiceResponse<JsonAtlasEntitiesWithExtInfoInner>, JsonAtlasEntitiesWithExtInfoInner>() {
            @Override
            public JsonAtlasEntitiesWithExtInfoInner call(ServiceResponse<JsonAtlasEntitiesWithExtInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Lists entities in bulk identified by its GUIDs.
     *
     * @param guid An array of GUIDs of entities to create.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasEntitiesWithExtInfoInner object
     */
    public Observable<ServiceResponse<JsonAtlasEntitiesWithExtInfoInner>> getByGuidsWithServiceResponseAsync(List<String> guid) {
        if (guid == null) {
            throw new IllegalArgumentException("Parameter guid is required and cannot be null.");
        }
        Validator.validate(guid);
        String guidConverted = this.client.serializerAdapter().serializeList(guid, CollectionFormat.MULTI);
        return service.getByGuids(guidConverted, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasEntitiesWithExtInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasEntitiesWithExtInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasEntitiesWithExtInfoInner> clientResponse = getByGuidsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasEntitiesWithExtInfoInner> getByGuidsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasEntitiesWithExtInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasEntitiesWithExtInfoInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates or updates entities in Atlas in bulk.
     Existing entity is matched using its unique guid if supplied or by its unique attributes eg: qualifiedName.
     Map and array of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string, int&gt;&gt;.
     *
     * @param entities An array of entities to create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonEntityMutationResponseInner object if successful.
     */
    public JsonEntityMutationResponseInner createOrUpdateBulk(JsonAtlasEntitiesWithExtInfoInner entities) {
        return createOrUpdateBulkWithServiceResponseAsync(entities).toBlocking().single().body();
    }

    /**
     * Creates or updates entities in Atlas in bulk.
     Existing entity is matched using its unique guid if supplied or by its unique attributes eg: qualifiedName.
     Map and array of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string, int&gt;&gt;.
     *
     * @param entities An array of entities to create or update.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonEntityMutationResponseInner> createOrUpdateBulkAsync(JsonAtlasEntitiesWithExtInfoInner entities, final ServiceCallback<JsonEntityMutationResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateBulkWithServiceResponseAsync(entities), serviceCallback);
    }

    /**
     * Creates or updates entities in Atlas in bulk.
     Existing entity is matched using its unique guid if supplied or by its unique attributes eg: qualifiedName.
     Map and array of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string, int&gt;&gt;.
     *
     * @param entities An array of entities to create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonEntityMutationResponseInner object
     */
    public Observable<JsonEntityMutationResponseInner> createOrUpdateBulkAsync(JsonAtlasEntitiesWithExtInfoInner entities) {
        return createOrUpdateBulkWithServiceResponseAsync(entities).map(new Func1<ServiceResponse<JsonEntityMutationResponseInner>, JsonEntityMutationResponseInner>() {
            @Override
            public JsonEntityMutationResponseInner call(ServiceResponse<JsonEntityMutationResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates or updates entities in Atlas in bulk.
     Existing entity is matched using its unique guid if supplied or by its unique attributes eg: qualifiedName.
     Map and array of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string, int&gt;&gt;.
     *
     * @param entities An array of entities to create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonEntityMutationResponseInner object
     */
    public Observable<ServiceResponse<JsonEntityMutationResponseInner>> createOrUpdateBulkWithServiceResponseAsync(JsonAtlasEntitiesWithExtInfoInner entities) {
        if (entities == null) {
            throw new IllegalArgumentException("Parameter entities is required and cannot be null.");
        }
        Validator.validate(entities);
        return service.createOrUpdateBulk(entities, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonEntityMutationResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonEntityMutationResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonEntityMutationResponseInner> clientResponse = createOrUpdateBulkDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonEntityMutationResponseInner> createOrUpdateBulkDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonEntityMutationResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonEntityMutationResponseInner>() { }.getType())
                .register(201, new TypeToken<JsonEntityMutationResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a list of entities in bulk identified by their GUIDs or unique attributes.
     *
     * @param guid An array of GUIDs of entities to delete. Use an empty list if not applicable.
     * @param atlasObjectIdWithParentGuidList An array of Atlas Object Id to be deleted. Use an empty list if not applicable.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonEntityMutationResponseInner object if successful.
     */
    public JsonEntityMutationResponseInner bulkDelete(List<String> guid, List<JsonAtlasObjectIdWithParentGuid> atlasObjectIdWithParentGuidList) {
        return bulkDeleteWithServiceResponseAsync(guid, atlasObjectIdWithParentGuidList).toBlocking().single().body();
    }

    /**
     * Deletes a list of entities in bulk identified by their GUIDs or unique attributes.
     *
     * @param guid An array of GUIDs of entities to delete. Use an empty list if not applicable.
     * @param atlasObjectIdWithParentGuidList An array of Atlas Object Id to be deleted. Use an empty list if not applicable.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonEntityMutationResponseInner> bulkDeleteAsync(List<String> guid, List<JsonAtlasObjectIdWithParentGuid> atlasObjectIdWithParentGuidList, final ServiceCallback<JsonEntityMutationResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(bulkDeleteWithServiceResponseAsync(guid, atlasObjectIdWithParentGuidList), serviceCallback);
    }

    /**
     * Deletes a list of entities in bulk identified by their GUIDs or unique attributes.
     *
     * @param guid An array of GUIDs of entities to delete. Use an empty list if not applicable.
     * @param atlasObjectIdWithParentGuidList An array of Atlas Object Id to be deleted. Use an empty list if not applicable.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonEntityMutationResponseInner object
     */
    public Observable<JsonEntityMutationResponseInner> bulkDeleteAsync(List<String> guid, List<JsonAtlasObjectIdWithParentGuid> atlasObjectIdWithParentGuidList) {
        return bulkDeleteWithServiceResponseAsync(guid, atlasObjectIdWithParentGuidList).map(new Func1<ServiceResponse<JsonEntityMutationResponseInner>, JsonEntityMutationResponseInner>() {
            @Override
            public JsonEntityMutationResponseInner call(ServiceResponse<JsonEntityMutationResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a list of entities in bulk identified by their GUIDs or unique attributes.
     *
     * @param guid An array of GUIDs of entities to delete. Use an empty list if not applicable.
     * @param atlasObjectIdWithParentGuidList An array of Atlas Object Id to be deleted. Use an empty list if not applicable.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonEntityMutationResponseInner object
     */
    public Observable<ServiceResponse<JsonEntityMutationResponseInner>> bulkDeleteWithServiceResponseAsync(List<String> guid, List<JsonAtlasObjectIdWithParentGuid> atlasObjectIdWithParentGuidList) {
        if (guid == null) {
            throw new IllegalArgumentException("Parameter guid is required and cannot be null.");
        }
        if (atlasObjectIdWithParentGuidList == null) {
            throw new IllegalArgumentException("Parameter atlasObjectIdWithParentGuidList is required and cannot be null.");
        }
        Validator.validate(guid);
        Validator.validate(atlasObjectIdWithParentGuidList);
        String guidConverted = this.client.serializerAdapter().serializeList(guid, CollectionFormat.MULTI);
        return service.bulkDelete(guidConverted, atlasObjectIdWithParentGuidList, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonEntityMutationResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonEntityMutationResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonEntityMutationResponseInner> clientResponse = bulkDeleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonEntityMutationResponseInner> bulkDeleteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonEntityMutationResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonEntityMutationResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Associates a classification to multiple entities in bulk.
     *
     * @param request The request to associate a classification to multiple entities.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void addClassification(JsonClassificationAssociateRequest request) {
        addClassificationWithServiceResponseAsync(request).toBlocking().single().body();
    }

    /**
     * Associates a classification to multiple entities in bulk.
     *
     * @param request The request to associate a classification to multiple entities.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> addClassificationAsync(JsonClassificationAssociateRequest request, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(addClassificationWithServiceResponseAsync(request), serviceCallback);
    }

    /**
     * Associates a classification to multiple entities in bulk.
     *
     * @param request The request to associate a classification to multiple entities.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> addClassificationAsync(JsonClassificationAssociateRequest request) {
        return addClassificationWithServiceResponseAsync(request).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Associates a classification to multiple entities in bulk.
     *
     * @param request The request to associate a classification to multiple entities.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> addClassificationWithServiceResponseAsync(JsonClassificationAssociateRequest request) {
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.addClassification(request, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = addClassificationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> addClassificationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets complete definition of an entity given its GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasEntityWithExtInfoInner object if successful.
     */
    public JsonAtlasEntityWithExtInfoInner getById(String guid) {
        return getByIdWithServiceResponseAsync(guid).toBlocking().single().body();
    }

    /**
     * Gets complete definition of an entity given its GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasEntityWithExtInfoInner> getByIdAsync(String guid, final ServiceCallback<JsonAtlasEntityWithExtInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getByIdWithServiceResponseAsync(guid), serviceCallback);
    }

    /**
     * Gets complete definition of an entity given its GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasEntityWithExtInfoInner object
     */
    public Observable<JsonAtlasEntityWithExtInfoInner> getByIdAsync(String guid) {
        return getByIdWithServiceResponseAsync(guid).map(new Func1<ServiceResponse<JsonAtlasEntityWithExtInfoInner>, JsonAtlasEntityWithExtInfoInner>() {
            @Override
            public JsonAtlasEntityWithExtInfoInner call(ServiceResponse<JsonAtlasEntityWithExtInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets complete definition of an entity given its GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasEntityWithExtInfoInner object
     */
    public Observable<ServiceResponse<JsonAtlasEntityWithExtInfoInner>> getByIdWithServiceResponseAsync(String guid) {
        if (guid == null) {
            throw new IllegalArgumentException("Parameter guid is required and cannot be null.");
        }
        return service.getById(guid, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasEntityWithExtInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasEntityWithExtInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasEntityWithExtInfoInner> clientResponse = getByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasEntityWithExtInfoInner> getByIdDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasEntityWithExtInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasEntityWithExtInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates entity partially - creates or updates entity attribute identified by its GUID.
     Supports only uprimitive attribute type and entity references.
     It does not support updation of complex types like arrays, and maps.
     Null updates are not possible.
     *
     * @param guid The globally unique identifier of the entity.
     * @param name The name of the attribute.
     * @param body The value of the attribute.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonEntityMutationResponseInner object if successful.
     */
    public JsonEntityMutationResponseInner partialUpdateEntityAttrByGuid(String guid, String name, Object body) {
        return partialUpdateEntityAttrByGuidWithServiceResponseAsync(guid, name, body).toBlocking().single().body();
    }

    /**
     * Updates entity partially - creates or updates entity attribute identified by its GUID.
     Supports only uprimitive attribute type and entity references.
     It does not support updation of complex types like arrays, and maps.
     Null updates are not possible.
     *
     * @param guid The globally unique identifier of the entity.
     * @param name The name of the attribute.
     * @param body The value of the attribute.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonEntityMutationResponseInner> partialUpdateEntityAttrByGuidAsync(String guid, String name, Object body, final ServiceCallback<JsonEntityMutationResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(partialUpdateEntityAttrByGuidWithServiceResponseAsync(guid, name, body), serviceCallback);
    }

    /**
     * Updates entity partially - creates or updates entity attribute identified by its GUID.
     Supports only uprimitive attribute type and entity references.
     It does not support updation of complex types like arrays, and maps.
     Null updates are not possible.
     *
     * @param guid The globally unique identifier of the entity.
     * @param name The name of the attribute.
     * @param body The value of the attribute.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonEntityMutationResponseInner object
     */
    public Observable<JsonEntityMutationResponseInner> partialUpdateEntityAttrByGuidAsync(String guid, String name, Object body) {
        return partialUpdateEntityAttrByGuidWithServiceResponseAsync(guid, name, body).map(new Func1<ServiceResponse<JsonEntityMutationResponseInner>, JsonEntityMutationResponseInner>() {
            @Override
            public JsonEntityMutationResponseInner call(ServiceResponse<JsonEntityMutationResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates entity partially - creates or updates entity attribute identified by its GUID.
     Supports only uprimitive attribute type and entity references.
     It does not support updation of complex types like arrays, and maps.
     Null updates are not possible.
     *
     * @param guid The globally unique identifier of the entity.
     * @param name The name of the attribute.
     * @param body The value of the attribute.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonEntityMutationResponseInner object
     */
    public Observable<ServiceResponse<JsonEntityMutationResponseInner>> partialUpdateEntityAttrByGuidWithServiceResponseAsync(String guid, String name, Object body) {
        if (guid == null) {
            throw new IllegalArgumentException("Parameter guid is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        return service.partialUpdateEntityAttrByGuid(guid, name, body, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonEntityMutationResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonEntityMutationResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonEntityMutationResponseInner> clientResponse = partialUpdateEntityAttrByGuidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonEntityMutationResponseInner> partialUpdateEntityAttrByGuidDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonEntityMutationResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<JsonEntityMutationResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes an entity identified by its GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonEntityMutationResponseInner object if successful.
     */
    public JsonEntityMutationResponseInner deleteByGuid(String guid) {
        return deleteByGuidWithServiceResponseAsync(guid).toBlocking().single().body();
    }

    /**
     * Deletes an entity identified by its GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonEntityMutationResponseInner> deleteByGuidAsync(String guid, final ServiceCallback<JsonEntityMutationResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(deleteByGuidWithServiceResponseAsync(guid), serviceCallback);
    }

    /**
     * Deletes an entity identified by its GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonEntityMutationResponseInner object
     */
    public Observable<JsonEntityMutationResponseInner> deleteByGuidAsync(String guid) {
        return deleteByGuidWithServiceResponseAsync(guid).map(new Func1<ServiceResponse<JsonEntityMutationResponseInner>, JsonEntityMutationResponseInner>() {
            @Override
            public JsonEntityMutationResponseInner call(ServiceResponse<JsonEntityMutationResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes an entity identified by its GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonEntityMutationResponseInner object
     */
    public Observable<ServiceResponse<JsonEntityMutationResponseInner>> deleteByGuidWithServiceResponseAsync(String guid) {
        if (guid == null) {
            throw new IllegalArgumentException("Parameter guid is required and cannot be null.");
        }
        return service.deleteByGuid(guid, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonEntityMutationResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonEntityMutationResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonEntityMutationResponseInner> clientResponse = deleteByGuidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonEntityMutationResponseInner> deleteByGuidDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonEntityMutationResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<JsonEntityMutationResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists classifications for a given entity represented by a GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @param classificationName The name of the classification.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasClassificationInner object if successful.
     */
    public JsonAtlasClassificationInner getClassification(String guid, String classificationName) {
        return getClassificationWithServiceResponseAsync(guid, classificationName).toBlocking().single().body();
    }

    /**
     * Lists classifications for a given entity represented by a GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @param classificationName The name of the classification.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasClassificationInner> getClassificationAsync(String guid, String classificationName, final ServiceCallback<JsonAtlasClassificationInner> serviceCallback) {
        return ServiceFuture.fromResponse(getClassificationWithServiceResponseAsync(guid, classificationName), serviceCallback);
    }

    /**
     * Lists classifications for a given entity represented by a GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @param classificationName The name of the classification.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasClassificationInner object
     */
    public Observable<JsonAtlasClassificationInner> getClassificationAsync(String guid, String classificationName) {
        return getClassificationWithServiceResponseAsync(guid, classificationName).map(new Func1<ServiceResponse<JsonAtlasClassificationInner>, JsonAtlasClassificationInner>() {
            @Override
            public JsonAtlasClassificationInner call(ServiceResponse<JsonAtlasClassificationInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Lists classifications for a given entity represented by a GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @param classificationName The name of the classification.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasClassificationInner object
     */
    public Observable<ServiceResponse<JsonAtlasClassificationInner>> getClassificationWithServiceResponseAsync(String guid, String classificationName) {
        if (guid == null) {
            throw new IllegalArgumentException("Parameter guid is required and cannot be null.");
        }
        if (classificationName == null) {
            throw new IllegalArgumentException("Parameter classificationName is required and cannot be null.");
        }
        return service.getClassification(guid, classificationName, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasClassificationInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasClassificationInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasClassificationInner> clientResponse = getClassificationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasClassificationInner> getClassificationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasClassificationInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasClassificationInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a given classification from an existing entity represented by a GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @param classificationName The name of the classification.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteClassification(String guid, String classificationName) {
        deleteClassificationWithServiceResponseAsync(guid, classificationName).toBlocking().single().body();
    }

    /**
     * Deletes a given classification from an existing entity represented by a GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @param classificationName The name of the classification.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteClassificationAsync(String guid, String classificationName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteClassificationWithServiceResponseAsync(guid, classificationName), serviceCallback);
    }

    /**
     * Deletes a given classification from an existing entity represented by a GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @param classificationName The name of the classification.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteClassificationAsync(String guid, String classificationName) {
        return deleteClassificationWithServiceResponseAsync(guid, classificationName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a given classification from an existing entity represented by a GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @param classificationName The name of the classification.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteClassificationWithServiceResponseAsync(String guid, String classificationName) {
        if (guid == null) {
            throw new IllegalArgumentException("Parameter guid is required and cannot be null.");
        }
        if (classificationName == null) {
            throw new IllegalArgumentException("Parameter classificationName is required and cannot be null.");
        }
        return service.deleteClassification(guid, classificationName, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteClassificationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteClassificationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists classifications for a given entity represented by a GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasClassificationsInner object if successful.
     */
    public JsonAtlasClassificationsInner getClassifications(String guid) {
        return getClassificationsWithServiceResponseAsync(guid).toBlocking().single().body();
    }

    /**
     * Lists classifications for a given entity represented by a GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasClassificationsInner> getClassificationsAsync(String guid, final ServiceCallback<JsonAtlasClassificationsInner> serviceCallback) {
        return ServiceFuture.fromResponse(getClassificationsWithServiceResponseAsync(guid), serviceCallback);
    }

    /**
     * Lists classifications for a given entity represented by a GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasClassificationsInner object
     */
    public Observable<JsonAtlasClassificationsInner> getClassificationsAsync(String guid) {
        return getClassificationsWithServiceResponseAsync(guid).map(new Func1<ServiceResponse<JsonAtlasClassificationsInner>, JsonAtlasClassificationsInner>() {
            @Override
            public JsonAtlasClassificationsInner call(ServiceResponse<JsonAtlasClassificationsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Lists classifications for a given entity represented by a GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasClassificationsInner object
     */
    public Observable<ServiceResponse<JsonAtlasClassificationsInner>> getClassificationsWithServiceResponseAsync(String guid) {
        if (guid == null) {
            throw new IllegalArgumentException("Parameter guid is required and cannot be null.");
        }
        return service.getClassifications(guid, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasClassificationsInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasClassificationsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasClassificationsInner> clientResponse = getClassificationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasClassificationsInner> getClassificationsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasClassificationsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasClassificationsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds classifications to an existing entity represented by a GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @param classifications An array of classifications to be added.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void addClassifications(String guid, List<JsonAtlasClassificationInner> classifications) {
        addClassificationsWithServiceResponseAsync(guid, classifications).toBlocking().single().body();
    }

    /**
     * Adds classifications to an existing entity represented by a GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @param classifications An array of classifications to be added.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> addClassificationsAsync(String guid, List<JsonAtlasClassificationInner> classifications, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(addClassificationsWithServiceResponseAsync(guid, classifications), serviceCallback);
    }

    /**
     * Adds classifications to an existing entity represented by a GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @param classifications An array of classifications to be added.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> addClassificationsAsync(String guid, List<JsonAtlasClassificationInner> classifications) {
        return addClassificationsWithServiceResponseAsync(guid, classifications).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds classifications to an existing entity represented by a GUID.
     *
     * @param guid The globally unique identifier of the entity.
     * @param classifications An array of classifications to be added.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> addClassificationsWithServiceResponseAsync(String guid, List<JsonAtlasClassificationInner> classifications) {
        if (guid == null) {
            throw new IllegalArgumentException("Parameter guid is required and cannot be null.");
        }
        if (classifications == null) {
            throw new IllegalArgumentException("Parameter classifications is required and cannot be null.");
        }
        Validator.validate(classifications);
        return service.addClassifications(guid, classifications, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = addClassificationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> addClassificationsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates classifications to an existing entity represented by a guid.
     *
     * @param guid The globally unique identifier of the entity.
     * @param classifications An array of classifications to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateClassifications(String guid, List<JsonAtlasClassificationInner> classifications) {
        updateClassificationsWithServiceResponseAsync(guid, classifications).toBlocking().single().body();
    }

    /**
     * Updates classifications to an existing entity represented by a guid.
     *
     * @param guid The globally unique identifier of the entity.
     * @param classifications An array of classifications to be updated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateClassificationsAsync(String guid, List<JsonAtlasClassificationInner> classifications, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateClassificationsWithServiceResponseAsync(guid, classifications), serviceCallback);
    }

    /**
     * Updates classifications to an existing entity represented by a guid.
     *
     * @param guid The globally unique identifier of the entity.
     * @param classifications An array of classifications to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateClassificationsAsync(String guid, List<JsonAtlasClassificationInner> classifications) {
        return updateClassificationsWithServiceResponseAsync(guid, classifications).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates classifications to an existing entity represented by a guid.
     *
     * @param guid The globally unique identifier of the entity.
     * @param classifications An array of classifications to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateClassificationsWithServiceResponseAsync(String guid, List<JsonAtlasClassificationInner> classifications) {
        if (guid == null) {
            throw new IllegalArgumentException("Parameter guid is required and cannot be null.");
        }
        if (classifications == null) {
            throw new IllegalArgumentException("Parameter classifications is required and cannot be null.");
        }
        Validator.validate(classifications);
        return service.updateClassifications(guid, classifications, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateClassificationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> updateClassificationsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets complete definition of an entity given its type and unique attribute.
     In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format:
     attr:&lt;attrName&gt;=&lt;attrValue&gt;.
     NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
     The REST request would look something like this:
     GET /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
     *
     * @param typeName The name of the type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonAtlasEntityWithExtInfoInner object if successful.
     */
    public JsonAtlasEntityWithExtInfoInner getByUniqueAttributes(String typeName) {
        return getByUniqueAttributesWithServiceResponseAsync(typeName).toBlocking().single().body();
    }

    /**
     * Gets complete definition of an entity given its type and unique attribute.
     In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format:
     attr:&lt;attrName&gt;=&lt;attrValue&gt;.
     NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
     The REST request would look something like this:
     GET /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
     *
     * @param typeName The name of the type.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonAtlasEntityWithExtInfoInner> getByUniqueAttributesAsync(String typeName, final ServiceCallback<JsonAtlasEntityWithExtInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getByUniqueAttributesWithServiceResponseAsync(typeName), serviceCallback);
    }

    /**
     * Gets complete definition of an entity given its type and unique attribute.
     In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format:
     attr:&lt;attrName&gt;=&lt;attrValue&gt;.
     NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
     The REST request would look something like this:
     GET /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
     *
     * @param typeName The name of the type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasEntityWithExtInfoInner object
     */
    public Observable<JsonAtlasEntityWithExtInfoInner> getByUniqueAttributesAsync(String typeName) {
        return getByUniqueAttributesWithServiceResponseAsync(typeName).map(new Func1<ServiceResponse<JsonAtlasEntityWithExtInfoInner>, JsonAtlasEntityWithExtInfoInner>() {
            @Override
            public JsonAtlasEntityWithExtInfoInner call(ServiceResponse<JsonAtlasEntityWithExtInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets complete definition of an entity given its type and unique attribute.
     In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format:
     attr:&lt;attrName&gt;=&lt;attrValue&gt;.
     NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
     The REST request would look something like this:
     GET /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
     *
     * @param typeName The name of the type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonAtlasEntityWithExtInfoInner object
     */
    public Observable<ServiceResponse<JsonAtlasEntityWithExtInfoInner>> getByUniqueAttributesWithServiceResponseAsync(String typeName) {
        if (typeName == null) {
            throw new IllegalArgumentException("Parameter typeName is required and cannot be null.");
        }
        return service.getByUniqueAttributes(typeName, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonAtlasEntityWithExtInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonAtlasEntityWithExtInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonAtlasEntityWithExtInfoInner> clientResponse = getByUniqueAttributesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonAtlasEntityWithExtInfoInner> getByUniqueAttributesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonAtlasEntityWithExtInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<JsonAtlasEntityWithExtInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates entity partially - Allows a subset of attributes to be updated on
     an entity which is identified by its type and unique attribute  eg: Referenceable.qualifiedName.
     Null updates are not possible.
     In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format:
     attr:&lt;attrName&gt;=&lt;attrValue&gt;.
     NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
     The REST request would look something like this:
     PUT /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
     *
     * @param typeName The name of the type.
     * @param atlasEntityWithExtInfo Atlas entity with extended information.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonEntityMutationResponseInner object if successful.
     */
    public JsonEntityMutationResponseInner partialUpdateEntityByUniqueAttrs(String typeName, JsonAtlasEntityWithExtInfoInner atlasEntityWithExtInfo) {
        return partialUpdateEntityByUniqueAttrsWithServiceResponseAsync(typeName, atlasEntityWithExtInfo).toBlocking().single().body();
    }

    /**
     * Updates entity partially - Allows a subset of attributes to be updated on
     an entity which is identified by its type and unique attribute  eg: Referenceable.qualifiedName.
     Null updates are not possible.
     In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format:
     attr:&lt;attrName&gt;=&lt;attrValue&gt;.
     NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
     The REST request would look something like this:
     PUT /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
     *
     * @param typeName The name of the type.
     * @param atlasEntityWithExtInfo Atlas entity with extended information.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonEntityMutationResponseInner> partialUpdateEntityByUniqueAttrsAsync(String typeName, JsonAtlasEntityWithExtInfoInner atlasEntityWithExtInfo, final ServiceCallback<JsonEntityMutationResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(partialUpdateEntityByUniqueAttrsWithServiceResponseAsync(typeName, atlasEntityWithExtInfo), serviceCallback);
    }

    /**
     * Updates entity partially - Allows a subset of attributes to be updated on
     an entity which is identified by its type and unique attribute  eg: Referenceable.qualifiedName.
     Null updates are not possible.
     In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format:
     attr:&lt;attrName&gt;=&lt;attrValue&gt;.
     NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
     The REST request would look something like this:
     PUT /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
     *
     * @param typeName The name of the type.
     * @param atlasEntityWithExtInfo Atlas entity with extended information.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonEntityMutationResponseInner object
     */
    public Observable<JsonEntityMutationResponseInner> partialUpdateEntityByUniqueAttrsAsync(String typeName, JsonAtlasEntityWithExtInfoInner atlasEntityWithExtInfo) {
        return partialUpdateEntityByUniqueAttrsWithServiceResponseAsync(typeName, atlasEntityWithExtInfo).map(new Func1<ServiceResponse<JsonEntityMutationResponseInner>, JsonEntityMutationResponseInner>() {
            @Override
            public JsonEntityMutationResponseInner call(ServiceResponse<JsonEntityMutationResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates entity partially - Allows a subset of attributes to be updated on
     an entity which is identified by its type and unique attribute  eg: Referenceable.qualifiedName.
     Null updates are not possible.
     In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format:
     attr:&lt;attrName&gt;=&lt;attrValue&gt;.
     NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
     The REST request would look something like this:
     PUT /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
     *
     * @param typeName The name of the type.
     * @param atlasEntityWithExtInfo Atlas entity with extended information.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonEntityMutationResponseInner object
     */
    public Observable<ServiceResponse<JsonEntityMutationResponseInner>> partialUpdateEntityByUniqueAttrsWithServiceResponseAsync(String typeName, JsonAtlasEntityWithExtInfoInner atlasEntityWithExtInfo) {
        if (typeName == null) {
            throw new IllegalArgumentException("Parameter typeName is required and cannot be null.");
        }
        if (atlasEntityWithExtInfo == null) {
            throw new IllegalArgumentException("Parameter atlasEntityWithExtInfo is required and cannot be null.");
        }
        Validator.validate(atlasEntityWithExtInfo);
        return service.partialUpdateEntityByUniqueAttrs(typeName, atlasEntityWithExtInfo, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonEntityMutationResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonEntityMutationResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonEntityMutationResponseInner> clientResponse = partialUpdateEntityByUniqueAttrsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonEntityMutationResponseInner> partialUpdateEntityByUniqueAttrsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonEntityMutationResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<JsonEntityMutationResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes an entity identified by its type and unique attributes.
     In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format:
     attr:&lt;attrName&gt;=&lt;attrValue&gt;.
     NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
     The REST request would look something like this:
     DELETE /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
     *
     * @param typeName The name of the type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the JsonEntityMutationResponseInner object if successful.
     */
    public JsonEntityMutationResponseInner deleteByUniqueAttribute(String typeName) {
        return deleteByUniqueAttributeWithServiceResponseAsync(typeName).toBlocking().single().body();
    }

    /**
     * Deletes an entity identified by its type and unique attributes.
     In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format:
     attr:&lt;attrName&gt;=&lt;attrValue&gt;.
     NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
     The REST request would look something like this:
     DELETE /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
     *
     * @param typeName The name of the type.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<JsonEntityMutationResponseInner> deleteByUniqueAttributeAsync(String typeName, final ServiceCallback<JsonEntityMutationResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(deleteByUniqueAttributeWithServiceResponseAsync(typeName), serviceCallback);
    }

    /**
     * Deletes an entity identified by its type and unique attributes.
     In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format:
     attr:&lt;attrName&gt;=&lt;attrValue&gt;.
     NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
     The REST request would look something like this:
     DELETE /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
     *
     * @param typeName The name of the type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonEntityMutationResponseInner object
     */
    public Observable<JsonEntityMutationResponseInner> deleteByUniqueAttributeAsync(String typeName) {
        return deleteByUniqueAttributeWithServiceResponseAsync(typeName).map(new Func1<ServiceResponse<JsonEntityMutationResponseInner>, JsonEntityMutationResponseInner>() {
            @Override
            public JsonEntityMutationResponseInner call(ServiceResponse<JsonEntityMutationResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes an entity identified by its type and unique attributes.
     In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format:
     attr:&lt;attrName&gt;=&lt;attrValue&gt;.
     NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
     The REST request would look something like this:
     DELETE /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
     *
     * @param typeName The name of the type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the JsonEntityMutationResponseInner object
     */
    public Observable<ServiceResponse<JsonEntityMutationResponseInner>> deleteByUniqueAttributeWithServiceResponseAsync(String typeName) {
        if (typeName == null) {
            throw new IllegalArgumentException("Parameter typeName is required and cannot be null.");
        }
        return service.deleteByUniqueAttribute(typeName, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<JsonEntityMutationResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<JsonEntityMutationResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<JsonEntityMutationResponseInner> clientResponse = deleteByUniqueAttributeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<JsonEntityMutationResponseInner> deleteByUniqueAttributeDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<JsonEntityMutationResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<JsonEntityMutationResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a given classification from an entity identified by its type and unique attributes.
     *
     * @param typeName The name of the type.
     * @param classificationName The name of the classification.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteClassificationByUniqueAttribute(String typeName, String classificationName) {
        deleteClassificationByUniqueAttributeWithServiceResponseAsync(typeName, classificationName).toBlocking().single().body();
    }

    /**
     * Deletes a given classification from an entity identified by its type and unique attributes.
     *
     * @param typeName The name of the type.
     * @param classificationName The name of the classification.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteClassificationByUniqueAttributeAsync(String typeName, String classificationName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteClassificationByUniqueAttributeWithServiceResponseAsync(typeName, classificationName), serviceCallback);
    }

    /**
     * Deletes a given classification from an entity identified by its type and unique attributes.
     *
     * @param typeName The name of the type.
     * @param classificationName The name of the classification.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteClassificationByUniqueAttributeAsync(String typeName, String classificationName) {
        return deleteClassificationByUniqueAttributeWithServiceResponseAsync(typeName, classificationName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a given classification from an entity identified by its type and unique attributes.
     *
     * @param typeName The name of the type.
     * @param classificationName The name of the classification.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteClassificationByUniqueAttributeWithServiceResponseAsync(String typeName, String classificationName) {
        if (typeName == null) {
            throw new IllegalArgumentException("Parameter typeName is required and cannot be null.");
        }
        if (classificationName == null) {
            throw new IllegalArgumentException("Parameter classificationName is required and cannot be null.");
        }
        final String parentEntityGuid = null;
        final String attrqualifiedName = null;
        return service.deleteClassificationByUniqueAttribute(typeName, classificationName, parentEntityGuid, attrqualifiedName, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteClassificationByUniqueAttributeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes a given classification from an entity identified by its type and unique attributes.
     *
     * @param typeName The name of the type.
     * @param classificationName The name of the classification.
     * @param parentEntityGuid The GUID of the parent entity.
     * @param attrqualifiedName The qualified name of the entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteClassificationByUniqueAttribute(String typeName, String classificationName, String parentEntityGuid, String attrqualifiedName) {
        deleteClassificationByUniqueAttributeWithServiceResponseAsync(typeName, classificationName, parentEntityGuid, attrqualifiedName).toBlocking().single().body();
    }

    /**
     * Deletes a given classification from an entity identified by its type and unique attributes.
     *
     * @param typeName The name of the type.
     * @param classificationName The name of the classification.
     * @param parentEntityGuid The GUID of the parent entity.
     * @param attrqualifiedName The qualified name of the entity.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteClassificationByUniqueAttributeAsync(String typeName, String classificationName, String parentEntityGuid, String attrqualifiedName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteClassificationByUniqueAttributeWithServiceResponseAsync(typeName, classificationName, parentEntityGuid, attrqualifiedName), serviceCallback);
    }

    /**
     * Deletes a given classification from an entity identified by its type and unique attributes.
     *
     * @param typeName The name of the type.
     * @param classificationName The name of the classification.
     * @param parentEntityGuid The GUID of the parent entity.
     * @param attrqualifiedName The qualified name of the entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteClassificationByUniqueAttributeAsync(String typeName, String classificationName, String parentEntityGuid, String attrqualifiedName) {
        return deleteClassificationByUniqueAttributeWithServiceResponseAsync(typeName, classificationName, parentEntityGuid, attrqualifiedName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a given classification from an entity identified by its type and unique attributes.
     *
     * @param typeName The name of the type.
     * @param classificationName The name of the classification.
     * @param parentEntityGuid The GUID of the parent entity.
     * @param attrqualifiedName The qualified name of the entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteClassificationByUniqueAttributeWithServiceResponseAsync(String typeName, String classificationName, String parentEntityGuid, String attrqualifiedName) {
        if (typeName == null) {
            throw new IllegalArgumentException("Parameter typeName is required and cannot be null.");
        }
        if (classificationName == null) {
            throw new IllegalArgumentException("Parameter classificationName is required and cannot be null.");
        }
        return service.deleteClassificationByUniqueAttribute(typeName, classificationName, parentEntityGuid, attrqualifiedName, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteClassificationByUniqueAttributeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteClassificationByUniqueAttributeDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds classification to the entity identified by its type and unique attributes.
     *
     * @param typeName The name of the type.
     * @param atlasClassificationArray An array of classification to be added.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void addClassificationsByUniqueAttribute(String typeName, List<JsonAtlasClassificationInner> atlasClassificationArray) {
        addClassificationsByUniqueAttributeWithServiceResponseAsync(typeName, atlasClassificationArray).toBlocking().single().body();
    }

    /**
     * Adds classification to the entity identified by its type and unique attributes.
     *
     * @param typeName The name of the type.
     * @param atlasClassificationArray An array of classification to be added.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> addClassificationsByUniqueAttributeAsync(String typeName, List<JsonAtlasClassificationInner> atlasClassificationArray, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(addClassificationsByUniqueAttributeWithServiceResponseAsync(typeName, atlasClassificationArray), serviceCallback);
    }

    /**
     * Adds classification to the entity identified by its type and unique attributes.
     *
     * @param typeName The name of the type.
     * @param atlasClassificationArray An array of classification to be added.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> addClassificationsByUniqueAttributeAsync(String typeName, List<JsonAtlasClassificationInner> atlasClassificationArray) {
        return addClassificationsByUniqueAttributeWithServiceResponseAsync(typeName, atlasClassificationArray).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds classification to the entity identified by its type and unique attributes.
     *
     * @param typeName The name of the type.
     * @param atlasClassificationArray An array of classification to be added.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> addClassificationsByUniqueAttributeWithServiceResponseAsync(String typeName, List<JsonAtlasClassificationInner> atlasClassificationArray) {
        if (typeName == null) {
            throw new IllegalArgumentException("Parameter typeName is required and cannot be null.");
        }
        if (atlasClassificationArray == null) {
            throw new IllegalArgumentException("Parameter atlasClassificationArray is required and cannot be null.");
        }
        Validator.validate(atlasClassificationArray);
        return service.addClassificationsByUniqueAttribute(typeName, atlasClassificationArray, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = addClassificationsByUniqueAttributeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> addClassificationsByUniqueAttributeDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates classification on an entity identified by its type and unique attributes.
     *
     * @param typeName The name of the type.
     * @param atlasClassificationArray An array of classification to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateClassificationsByUniqueAttribute(String typeName, List<JsonAtlasClassificationInner> atlasClassificationArray) {
        updateClassificationsByUniqueAttributeWithServiceResponseAsync(typeName, atlasClassificationArray).toBlocking().single().body();
    }

    /**
     * Updates classification on an entity identified by its type and unique attributes.
     *
     * @param typeName The name of the type.
     * @param atlasClassificationArray An array of classification to be updated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateClassificationsByUniqueAttributeAsync(String typeName, List<JsonAtlasClassificationInner> atlasClassificationArray, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateClassificationsByUniqueAttributeWithServiceResponseAsync(typeName, atlasClassificationArray), serviceCallback);
    }

    /**
     * Updates classification on an entity identified by its type and unique attributes.
     *
     * @param typeName The name of the type.
     * @param atlasClassificationArray An array of classification to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateClassificationsByUniqueAttributeAsync(String typeName, List<JsonAtlasClassificationInner> atlasClassificationArray) {
        return updateClassificationsByUniqueAttributeWithServiceResponseAsync(typeName, atlasClassificationArray).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates classification on an entity identified by its type and unique attributes.
     *
     * @param typeName The name of the type.
     * @param atlasClassificationArray An array of classification to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateClassificationsByUniqueAttributeWithServiceResponseAsync(String typeName, List<JsonAtlasClassificationInner> atlasClassificationArray) {
        if (typeName == null) {
            throw new IllegalArgumentException("Parameter typeName is required and cannot be null.");
        }
        if (atlasClassificationArray == null) {
            throw new IllegalArgumentException("Parameter atlasClassificationArray is required and cannot be null.");
        }
        Validator.validate(atlasClassificationArray);
        return service.updateClassificationsByUniqueAttribute(typeName, atlasClassificationArray, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateClassificationsByUniqueAttributeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> updateClassificationsByUniqueAttributeDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
